/**
 * @file game_world_full.cpp
 * @brief Full implementation of ECS-based game world
 */

// All includes at global scope
#include <memory>
#include <vector>
#include <deque>
#include <algorithm>
#include <string>
#include <exception>
#include <variant>

#include "ecs/game_world.h"
#include "ecs/entity_factory.h"
#include "ecs/entity_adapter.h"
#include "ecs/movement_system.h"
#include "ecs/render_system.h"
#include "ecs/combat_system.h"
#include "ecs/ai_system.h"
#include "ecs/inventory_system.h"
#include "ecs/equipment_system.h"
#include "ecs/event.h"
#include "entity_manager.h"
#include "combat_system.h"
#include "player.h"
#include "monster.h"
#include "item.h"
#include "turn_manager.h"
#include "message_log_adapter.h"

// Forward declare Map to avoid include issues
class Map;

// Only now open the namespace
namespace ecs {

GameWorld::GameWorld(::EntityManager* entities, ::CombatSystem* /*combat*/,
                     MessageLog* log, ::Map* map)
    : legacy_entities(entities),
      message_log(log),
      game_map(map) {
    // Create ILogger adapter for MessageLog
    if (message_log) {
        logger = std::make_unique<MessageLogAdapter>(message_log);
    }
}

GameWorld::~GameWorld() = default;

void GameWorld::initialize(bool migrate_existing) {
    // Create bridge objects for legacy compatibility
    entity_bridge = std::make_unique<EntityManagerBridge>(legacy_entities);
    renderer_bridge = std::make_unique<RendererBridge>(entity_bridge.get());

    // Initialize all ECS systems
    initializeSystems();

    // Migrate existing entities if requested
    if (migrate_existing) {
        migrateExistingEntities();
    }
}

void GameWorld::initializeSystems() {
    // Register core systems with priorities
    auto& movement = world.registerSystem<MovementSystem>(game_map);
    world.registerSystem<RenderSystem>(game_map);

    // Register native ECS combat system
    native_combat_system = &world.registerSystem<CombatSystem>(message_log);

    // Register AI system with dependencies
    native_ai_system = &world.registerSystem<AISystem>(game_map, &movement,
                                                        native_combat_system,
                                                        message_log);

    // Register inventory system
    world.registerSystem<InventorySystem>(game_map, logger.get());

    // Register equipment system with world access
    world.registerSystem<EquipmentSystem>(logger.get(), &world);

    // Set player ID for AI targeting
    if (native_ai_system && player_id != 0) {
        native_ai_system->setPlayerId(player_id);
    }
}

void GameWorld::migrateExistingEntities() {
    if (!legacy_entities) return;

    // Get all legacy entities
    auto all_entities = legacy_entities->getAllEntities();

    for (const auto& legacy_entity : all_entities) {
        if (!legacy_entity) continue;

        // Create ECS entity based on type
        std::unique_ptr<Entity> ecs_entity;

        // Check entity type and convert appropriately
        if (auto player = std::dynamic_pointer_cast<Player>(legacy_entity)) {
            ecs_entity = EntityAdapter::fromPlayer(*player);

            // Track player ID
            if (ecs_entity) {
                player_id = ecs_entity->getID();

                // Update AI system with player ID
                if (native_ai_system) {
                    native_ai_system->setPlayerId(player_id);
                }
            }
        } else if (auto monster = std::dynamic_pointer_cast<Monster>(legacy_entity)) {
            ecs_entity = EntityAdapter::fromMonster(*monster);
        } else if (auto item = std::dynamic_pointer_cast<Item>(legacy_entity)) {
            ecs_entity = EntityAdapter::fromItem(*item);
        } else {
            // Generic entity migration
            ecs_entity = std::make_unique<Entity>();
            ecs_entity->addComponent<PositionComponent>(
                legacy_entity->getPosition().x,
                legacy_entity->getPosition().y
            );
            ecs_entity->addComponent<RenderableComponent>(
                legacy_entity->glyph,
                legacy_entity->color
            );
        }

        if (ecs_entity) {
            // Add to world and sync with bridge
            Entity& added = world.addEntity(std::move(ecs_entity));
            entity_bridge->syncEntity(legacy_entity,
                std::shared_ptr<Entity>(&added, [](Entity*){}));
        }
    }
}

void GameWorld::update(double delta_time) {
    // Process all queued events from previous frame
    EventSystem::getInstance().update();

    // Update all ECS systems
    world.update(delta_time);

    // Process any events generated by systems
    EventSystem::getInstance().update();

    // Remove dead entities
    removeDeadEntities();

    // Sync changes back to legacy systems
    syncToLegacy();
}

EntityID GameWorld::createPlayer(int x, int y) {
    // Create player using factory
    auto player_entity = PlayerFactory().create(x, y);
    EntityID id = player_entity->getID();

    // Add to world
    Entity& added = world.addEntity(std::move(player_entity));

    // Create legacy player if needed for compatibility
    if (legacy_entities) {
        auto legacy_player = legacy_entities->createPlayer(x, y);
        if (legacy_player) {
            entity_bridge->syncEntity(legacy_player,
                std::shared_ptr<Entity>(&added, [](Entity*){}));
        }
    }

    // Track player ID
    player_id = id;

    // Update AI system
    if (native_ai_system) {
        native_ai_system->setPlayerId(player_id);
    }

    return id;
}

EntityID GameWorld::createMonster(const std::string& type, int x, int y) {
    // Create monster using factory
    auto monster_entity = MonsterFactoryECS().create(type, x, y);
    EntityID id = monster_entity->getID();

    // Add to world
    Entity& added = world.addEntity(std::move(monster_entity));

    // Create legacy monster if needed
    if (legacy_entities) {
        auto legacy_monster = legacy_entities->createMonster(type, x, y);
        if (legacy_monster) {
            entity_bridge->syncEntity(legacy_monster,
                std::shared_ptr<Entity>(&added, [](Entity*){}));
        }
    }

    return id;
}

EntityID GameWorld::createItem(const std::string& type, int x, int y) {
    // Create item using factory
    auto item_entity = ItemFactoryECS().create(type, x, y);
    EntityID id = item_entity->getID();

    // Add to world
    world.addEntity(std::move(item_entity));

    // Create legacy item if needed
    if (legacy_entities) {
        // Legacy item creation would go here if available
    }

    return id;
}

Entity* GameWorld::getEntity(EntityID id) {
    return world.getEntity(id);
}

bool GameWorld::removeEntity(EntityID id) {
    // Don't remove player
    if (id == player_id) {
        return false;
    }

    // Remove from bridges if present
    if (entity_bridge) {
        entity_bridge->removeEntity(id);
    }

    return world.removeEntity(id);
}

std::vector<Entity*> GameWorld::getEntitiesAt(int x, int y) {
    std::vector<Entity*> result;

    for (const auto& entity : world.getEntities()) {
        auto* pos = entity->getComponent<PositionComponent>();
        if (pos && pos->isAt(x, y)) {
            result.push_back(entity.get());
        }
    }

    return result;
}

ActionSpeed GameWorld::processPlayerAction(int action, int dx, int dy) {
    // Get player entity
    Entity* player = getEntity(player_id);
    if (!player) {
        return ActionSpeed::NORMAL;
    }

    auto* pos = player->getComponent<PositionComponent>();
    if (!pos) {
        return ActionSpeed::NORMAL;
    }

    ActionSpeed speed = ActionSpeed::NORMAL;

    // Handle different actions
    switch (action) {
        case 0: // Movement
            if (dx != 0 || dy != 0) {
                int new_x = pos->position.x + dx;
                int new_y = pos->position.y + dy;

                // Check for combat (bump to attack)
                auto entities_at_target = getEntitiesAt(new_x, new_y);
                for (Entity* target : entities_at_target) {
                    if (target->hasComponent<CombatComponent>() &&
                        target->getID() != player_id) {
                        // Attack the target
                        if (native_combat_system) {
                            native_combat_system->queueAttack(player_id, target->getID());
                        }
                        return ActionSpeed::NORMAL;
                    }
                }

                // Move if no combat
                auto* movement = world.getSystem<MovementSystem>();
                if (movement) {
                    auto player_ptr = std::shared_ptr<Entity>(player, [](Entity*){});
                    if (movement->moveEntity(*player_ptr, new_x, new_y)) {
                        speed = ActionSpeed::NORMAL;
                    }
                }
            }
            break;

        case 1: // Pickup item
            {
                auto items_here = getEntitiesAt(pos->position.x, pos->position.y);
                auto* inv_system = world.getSystem<InventorySystem>();
                if (inv_system) {
                    for (Entity* item : items_here) {
                        if (item->hasComponent<ItemComponent>()) {
                            if (inv_system->pickupItem(player, item)) {
                                speed = ActionSpeed::FAST;
                                break;
                            }
                        }
                    }
                }
            }
            break;

        case 2: // Use item
            // Would need item selection UI
            speed = ActionSpeed::FAST;
            break;

        case 3: // Drop item
            // Would need item selection UI
            speed = ActionSpeed::FAST;
            break;

        case 4: // Wait
            speed = ActionSpeed::NORMAL;
            break;

        default:
            speed = ActionSpeed::NORMAL;
            break;
    }

    return speed;
}

void GameWorld::processMonsterAI() {
    // AI system handles this automatically in update loop
    // Just ensure player ID is set
    if (native_ai_system && player_id != 0) {
        native_ai_system->setPlayerId(player_id);
    }
}

void GameWorld::updateFOV(const std::vector<std::vector<bool>>& fov) {
    // Update visibility for all entities based on FOV
    for (const auto& entity : world.getEntities()) {
        auto* pos = entity->getComponent<PositionComponent>();
        auto* renderable = entity->getComponent<RenderableComponent>();

        if (pos && renderable) {
            if (pos->position.x >= 0 && pos->position.x < (int)fov.size() &&
                pos->position.y >= 0 && pos->position.y < (int)fov[0].size()) {
                renderable->is_visible = fov[pos->position.x][pos->position.y];
            }
        }
    }
}

void GameWorld::syncToLegacy() {
    if (!entity_bridge) return;

    // Sync all ECS entities back to legacy system
    for (const auto& entity : world.getEntities()) {
        entity_bridge->syncToLegacy(entity.get());
    }
}

void GameWorld::syncFromLegacy() {
    if (!entity_bridge) return;

    // Sync legacy entities to ECS
    if (legacy_entities) {
        auto all_entities = legacy_entities->getAllEntities();
        for (const auto& legacy_entity : all_entities) {
            entity_bridge->syncFromLegacy(legacy_entity);
        }
    }
}

MovementSystem* GameWorld::getMovementSystem() {
    return world.getSystem<MovementSystem>();
}

RenderSystem* GameWorld::getRenderSystem() {
    return world.getSystem<RenderSystem>();
}

bool GameWorld::isPositionBlocked(int x, int y) const {
    // Check map
    if (game_map && !game_map->isWalkable(x, y)) {
        return true;
    }

    // Check entities
    for (const auto& entity : world.getEntities()) {
        auto* pos = entity->getComponent<PositionComponent>();
        auto* combat = entity->getComponent<CombatComponent>();

        // Blocking entities have position and combat components
        if (pos && combat && pos->isAt(x, y)) {
            return true;
        }
    }

    return false;
}

void GameWorld::removeDeadEntities() {
    std::vector<EntityID> to_remove;

    for (const auto& entity : world.getEntities()) {
        auto* health = entity->getComponent<HealthComponent>();
        if (health && health->hp <= 0 && entity->getID() != player_id) {
            to_remove.push_back(entity->getID());

            // Drop items on death
            auto* inventory = entity->getComponent<InventoryComponent>();
            auto* pos = entity->getComponent<PositionComponent>();
            if (inventory && pos) {
                for (EntityID item_id : inventory->items) {
                    Entity* item = getEntity(item_id);
                    if (item) {
                        // Add position back to item
                        item->addComponent<PositionComponent>(
                            pos->position.x, pos->position.y
                        );
                    }
                }
            }

            // Log death message
            if (logger) {
                auto* renderable = entity->getComponent<RenderableComponent>();
                std::string name = renderable ? renderable->name : "Something";
                logger->logCombat(name + " dies!");
            }
        }
    }

    // Remove dead entities
    for (EntityID id : to_remove) {
        removeEntity(id);
    }
}

} // namespace ecs