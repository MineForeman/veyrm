# Phase 11.1: Inventory Storage Requirements

## Overview
Phase 11.1 implements the core inventory storage system that allows the player to carry items. This builds upon the Phase 10.1 Item Entity system by adding a container for items that the player has picked up.

## Goals
1. Create a flexible inventory system that can hold items
2. Implement capacity limits (weight and/or slot-based)
3. Integrate inventory with the Player entity
4. Support item stacking for stackable items
5. Provide query and manipulation methods for inventory contents

## Technical Requirements

### 1. Inventory Class
Create `include/inventory.h` and `src/inventory.cpp`:

```cpp
class Inventory {
public:
    // Configuration
    static constexpr int DEFAULT_CAPACITY = 26;  // a-z slots

    // Constructor
    explicit Inventory(int capacity = DEFAULT_CAPACITY);

    // Item Management
    bool addItem(std::unique_ptr<Item> item);
    std::unique_ptr<Item> removeItem(int slot);
    std::unique_ptr<Item> removeItem(Item* item);

    // Queries
    Item* getItem(int slot) const;
    Item* findItem(const std::string& item_id) const;
    std::vector<Item*> findItems(Item::ItemType type) const;
    int findSlot(Item* item) const;

    // Stack Management
    bool canStackWith(Item* item) const;
    Item* findStackableItem(const std::string& item_id) const;

    // Capacity
    bool isFull() const;
    bool hasSpace(int count = 1) const;
    int getUsedSlots() const;
    int getTotalSlots() const { return capacity; }

    // Weight (optional for MVP)
    int getTotalWeight() const;
    int getMaxWeight() const { return max_weight; }
    bool canCarry(const Item* item) const;

    // Utility
    void clear();
    void sort();  // Sort items by type/name
    std::vector<Item*> getAllItems() const;

private:
    int capacity;
    int max_weight;  // Optional weight limit
    std::vector<std::unique_ptr<Item>> items;

    // Helper methods
    int findEmptySlot() const;
    bool tryStack(Item* item);
};
```

### 2. Player Integration
Update `include/player.h`:

```cpp
class Player : public Entity {
public:
    // Add inventory member
    std::unique_ptr<Inventory> inventory;

    // Inventory helpers
    bool pickupItem(std::unique_ptr<Item> item);
    bool dropItem(int slot);
    bool hasItem(const std::string& item_id) const;
    int countItems(const std::string& item_id) const;

    // Constructor update
    Player(int x, int y);  // Initialize inventory here
};
```

Update `src/player.cpp`:
```cpp
Player::Player(int x, int y)
    : Entity(x, y),
      inventory(std::make_unique<Inventory>()) {
    // ... existing initialization
}

bool Player::pickupItem(std::unique_ptr<Item> item) {
    if (!item) return false;

    // Special handling for gold
    if (item->type == Item::ItemType::GOLD) {
        gold += item->properties["amount"];
        return true;  // Gold doesn't go in inventory
    }

    return inventory->addItem(std::move(item));
}
```

### 3. Game Integration
Update `src/game_screen.cpp` pickup handler:

```cpp
case InputAction::GET_ITEM: {
    auto* player = game_manager->getPlayer();
    auto* item_manager = game_manager->getItemManager();
    auto* msg_log = game_manager->getMessageLog();

    if (player && item_manager) {
        auto item = item_manager->getItemAt(player->x, player->y);
        if (item) {
            // Create a copy for inventory
            auto item_copy = ItemFactory::getInstance().create(item->id);
            if (item_copy) {
                item_copy->stack_size = item->stack_size;
                item_copy->properties = item->properties;

                if (player->pickupItem(std::move(item_copy))) {
                    msg_log->addMessage("You pick up " + item->name + ".");
                    item_manager->removeItem(item);
                    game_manager->processPlayerAction(ActionSpeed::FAST);
                } else {
                    msg_log->addMessage("Your inventory is full!");
                }
            }
        } else {
            msg_log->addMessage("There is nothing here to pick up.");
        }
    }
    return false;
}
```

### 4. Stacking Logic
Implement smart stacking for stackable items:

```cpp
bool Inventory::addItem(std::unique_ptr<Item> item) {
    if (!item) return false;

    // Try to stack first
    if (item->stackable && tryStack(item.get())) {
        return true;  // Item was stacked
    }

    // Find empty slot
    if (items.size() < capacity) {
        items.push_back(std::move(item));
        return true;
    }

    return false;  // Inventory full
}

bool Inventory::tryStack(Item* item) {
    if (!item->stackable) return false;

    for (auto& existing : items) {
        if (existing && existing->id == item->id &&
            existing->canStackWith(*item)) {

            int space = existing->max_stack - existing->stack_size;
            int to_add = std::min(space, item->stack_size);

            existing->stack_size += to_add;
            item->stack_size -= to_add;

            return item->stack_size == 0;  // All stacked?
        }
    }

    return false;
}
```

### 5. Save/Load Support
Prepare for future save system:

```cpp
// Serialization helpers
nlohmann::json Inventory::toJson() const {
    nlohmann::json j;
    j["capacity"] = capacity;
    j["max_weight"] = max_weight;
    j["items"] = nlohmann::json::array();

    for (const auto& item : items) {
        if (item) {
            j["items"].push_back(item->toJson());
        }
    }

    return j;
}

void Inventory::fromJson(const nlohmann::json& j) {
    capacity = j["capacity"];
    max_weight = j["max_weight"];
    items.clear();

    for (const auto& item_json : j["items"]) {
        auto item = Item::fromJson(item_json);
        if (item) {
            items.push_back(std::move(item));
        }
    }
}
```

## Implementation Steps

1. **Create Inventory Class**
   - Basic container with capacity
   - Add/remove/query methods
   - No UI yet (that's Phase 11.2)

2. **Add Stacking Support**
   - Smart stacking for same items
   - Respect max_stack limits
   - Handle partial stacks

3. **Integrate with Player**
   - Add inventory member
   - Update constructor
   - Add helper methods

4. **Update Pickup System**
   - Modify GET_ITEM handler
   - Check inventory space
   - Show appropriate messages

5. **Write Tests**
   - Test capacity limits
   - Test stacking behavior
   - Test add/remove operations
   - Test Player integration

## Configuration
Add to `config.yml`:
```yaml
player:
  inventory_capacity: 26  # Number of slots
  max_carry_weight: 100   # Optional weight limit

items:
  auto_stack: true        # Automatically stack items
  sort_on_pickup: false   # Sort inventory when adding
```

## Testing Requirements

### Unit Tests (`tests/test_inventory.cpp`)
1. **Capacity Tests**
   - Can add items up to capacity
   - Rejects items when full
   - Tracks used/free slots correctly

2. **Stacking Tests**
   - Stacks identical stackable items
   - Respects max_stack limits
   - Handles partial stacks
   - Non-stackable items don't stack

3. **Query Tests**
   - Find items by ID
   - Find items by type
   - Get items by slot
   - Find empty slots

4. **Integration Tests**
   - Player can pick up items
   - Inventory persists across turns
   - Gold bypasses inventory

### Manual Testing
1. Pick up items until inventory is full
2. Verify "inventory full" message
3. Pick up stackable items and verify stacking
4. Pick up gold and verify it doesn't use slots

## Success Criteria
- [x] Inventory class created with capacity management
- [x] Items can be added and removed
- [x] Stacking works for stackable items
- [x] Player has functioning inventory
- [x] Pickup system uses inventory
- [x] All unit tests pass
- [x] No memory leaks

## Future Enhancements (Post-MVP)
1. **Weight System**
   - Track total weight
   - Encumbrance effects
   - Strength-based capacity

2. **Quick Slots**
   - Designated slots for potions
   - Hotkey access

3. **Auto-Pickup**
   - Configure auto-pickup rules
   - Gold always auto-pickup

4. **Sorting Options**
   - Sort by type
   - Sort by value
   - Sort by weight
   - Custom sort order

5. **Container Items**
   - Bags increase capacity
   - Specialized containers (potion belt, scroll case)

## Dependencies
- Phase 10.1: Item Entity System (COMPLETE)
- Existing Player class
- Existing Item/ItemFactory/ItemManager

## Risks and Mitigations
1. **Risk**: Memory management complexity
   - **Mitigation**: Use smart pointers throughout

2. **Risk**: Stacking edge cases
   - **Mitigation**: Comprehensive unit tests

3. **Risk**: Save/load compatibility
   - **Mitigation**: Design with serialization in mind

## Notes
- Keep UI separate (that's Phase 11.2)
- Focus on core functionality first
- Make system extensible for future features
- Consider weight limits but make them optional
- Use slot-based system for simplicity (a-z mapping)