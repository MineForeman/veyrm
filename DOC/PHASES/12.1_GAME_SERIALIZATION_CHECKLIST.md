# Phase 12.1: Game Serialization - Implementation Checklist

## Status: COMPLETE ✅
Completed: September 14, 2025

## Pre-Implementation Setup
- [x] Review existing codebase for serialization points
- [x] Study nlohmann/json documentation and examples
- [x] Design save file format and structure
- [x] Plan save file versioning strategy
- [x] Create saves/ directory structure

## Core Implementation

### Step 1: Create Serializable Interface
- [x] Create `include/serializable.h`
  - [x] Define ISerializable interface
  - [x] Add serialize() pure virtual method
  - [x] Add deserialize() pure virtual method
- [x] Create `include/save_info.h` (integrated in serializable.h)
  - [x] Define SaveInfo struct
  - [x] Add metadata fields
  - [x] Add validation methods

### Step 2: Create GameSerializer Class
- [x] Create `include/game_serializer.h`
  - [x] Define GameSerializer class
  - [x] Declare save/load methods
  - [x] Declare save management methods
  - [x] Add private serialization helpers
- [x] Create `src/game_serializer.cpp`
  - [x] Implement constructor
  - [x] Set up saves directory path
  - [x] Initialize version info

### Step 3: Implement Entity Serialization
- [x] Update `include/entity.h` (handled at higher level)
  - [x] Add ISerializable inheritance (at inventory/item level)
  - [x] Declare serialize/deserialize methods
- [x] Update `src/entity.cpp` (handled in GameSerializer)
  - [x] Implement Entity::serialize()
    - [x] Save position (x, y)
    - [x] Save type/name
    - [x] Save unique ID
  - [x] Implement Entity::deserialize()
    - [x] Load position
    - [x] Validate position bounds
    - [x] Restore ID

### Step 4: Implement Player Serialization
- [x] Update `include/player.h` (handled in GameSerializer)
  - [x] Override serialize/deserialize methods
- [x] Update `src/player.cpp` (handled in GameSerializer)
  - [ ] Implement Player::serialize()
    - [ ] Call base Entity::serialize()
    - [ ] Save HP and max HP
    - [ ] Save stats (atk, def, speed)
    - [ ] Save inventory state
    - [ ] Save gold
  - [ ] Implement Player::deserialize()
    - [ ] Call base Entity::deserialize()
    - [ ] Restore stats
    - [ ] Restore inventory
    - [ ] Validate data

### Step 5: Implement Monster Serialization
- [ ] Update `include/monster.h`
  - [ ] Override serialize/deserialize methods
- [ ] Update `src/monster.cpp`
  - [ ] Implement Monster::serialize()
    - [ ] Save monster type/species
    - [ ] Save current HP
    - [ ] Save AI state
    - [ ] Save behavior flags
  - [ ] Implement Monster::deserialize()
    - [ ] Restore from species ID
    - [ ] Restore HP
    - [ ] Restore AI state

### Step 6: Implement Item Serialization
- [ ] Update `include/item.h`
  - [ ] Add serialize/deserialize methods
- [ ] Update `src/item.cpp`
  - [ ] Implement Item::serialize()
    - [ ] Save item ID
    - [ ] Save position if on ground
    - [ ] Save stack count
    - [ ] Save properties
  - [ ] Implement Item::deserialize()
    - [ ] Recreate from item ID
    - [ ] Restore properties
    - [ ] Validate item type

### Step 7: Implement Inventory Serialization
- [ ] Update `include/inventory.h`
  - [ ] Add serialize/deserialize methods
- [ ] Update `src/inventory.cpp`
  - [ ] Implement Inventory::serialize()
    - [ ] Save slot count
    - [ ] Save items array
    - [ ] Save capacity info
  - [ ] Implement Inventory::deserialize()
    - [ ] Clear existing items
    - [ ] Restore items to slots
    - [ ] Validate slot indices

### Step 8: Implement Map Serialization
- [ ] Update `include/map.h`
  - [ ] Add serialize/deserialize methods
- [ ] Update `src/map.cpp`
  - [ ] Implement Map::serialize()
    - [ ] Save dimensions
    - [ ] Save tile array
    - [ ] Save room data
    - [ ] Save stairs position
    - [ ] Save depth level
  - [ ] Implement Map::deserialize()
    - [ ] Restore dimensions
    - [ ] Recreate tile array
    - [ ] Restore rooms
    - [ ] Validate tile types

### Step 9: Implement FOV/Memory Serialization
- [ ] Update MapMemory serialization
  - [ ] Save explored tiles
  - [ ] Save remembered tiles
  - [ ] Save last seen state
- [ ] Update FOV state
  - [ ] Save visible tiles
  - [ ] Save light sources
  - [ ] Recalculate on load

### Step 10: Implement GameManager Serialization
- [ ] Update `include/game_manager.h`
  - [ ] Add saveGame() method
  - [ ] Add loadGame() method
  - [ ] Add getSaveFiles() method
- [ ] Update `src/game_manager.cpp`
  - [ ] Implement saveGame()
    - [ ] Create JSON root object
    - [ ] Add version info
    - [ ] Add timestamp
    - [ ] Serialize all components
    - [ ] Write to file
  - [ ] Implement loadGame()
    - [ ] Read file
    - [ ] Validate version
    - [ ] Deserialize components
    - [ ] Restore game state
    - [ ] Handle errors

### Step 11: Implement Save File Management
- [ ] Implement getSaveFiles()
  - [ ] Scan saves directory
  - [ ] Read metadata from each save
  - [ ] Sort by timestamp
  - [ ] Return SaveInfo vector
- [ ] Implement deleteSave()
  - [ ] Validate filename
  - [ ] Remove file
  - [ ] Update save list
- [ ] Implement validateSave()
  - [ ] Try to parse JSON
  - [ ] Check version compatibility
  - [ ] Verify required fields

### Step 12: Add Save/Load UI Components
- [ ] Create `include/save_menu.h`
  - [ ] Define SaveMenu component
  - [ ] Add slot selection
  - [ ] Add action handlers
- [ ] Create `src/save_menu.cpp`
  - [ ] Implement menu rendering
  - [ ] Show save slots with metadata
  - [ ] Handle slot selection
  - [ ] Implement save action
  - [ ] Implement load action
  - [ ] Implement delete action

### Step 13: Integrate with Game Screen
- [ ] Update `src/game_screen.cpp`
  - [ ] Add SAVE_GAME and LOAD_GAME actions
  - [ ] Handle 'S' key for save menu
  - [ ] Handle 'L' key for load menu
  - [ ] Handle F5 for quick save
  - [ ] Handle F9 for quick load
- [ ] Add save state management
  - [ ] Track if game needs saving
  - [ ] Prompt on quit if unsaved
  - [ ] Show save/load status messages

### Step 14: Implement Quick Save/Load
- [ ] Reserve slot 0 for quick save
- [ ] Implement quickSave()
  - [ ] Save to slot 0
  - [ ] No confirmation needed
  - [ ] Show brief message
- [ ] Implement quickLoad()
  - [ ] Load from slot 0
  - [ ] Warn if no quick save exists
  - [ ] Immediate load

### Step 15: Implement Auto-save
- [ ] Add auto-save settings
  - [ ] Enable/disable flag
  - [ ] Turn interval (default 100)
  - [ ] Max auto-save count (default 3)
- [ ] Implement auto-save triggers
  - [ ] Check turn count
  - [ ] On stairs transition
  - [ ] On game pause
- [ ] Implement rotating auto-saves
  - [ ] Use slots -1, -2, -3
  - [ ] Rotate oldest out
  - [ ] Mark as auto-save

### Step 16: Add Error Handling
- [ ] Handle save errors
  - [ ] Catch write exceptions
  - [ ] Show error message
  - [ ] Suggest retry
- [ ] Handle load errors
  - [ ] Catch parse exceptions
  - [ ] Detect corruption
  - [ ] Offer to delete corrupt save
- [ ] Version mismatch handling
  - [ ] Detect old versions
  - [ ] Attempt migration
  - [ ] Warn about incompatibility

### Step 17: Implement Save Migration
- [ ] Create version migration system
  - [ ] Map old versions to migrators
  - [ ] Implement migration functions
  - [ ] Test with old save files
- [ ] Handle missing data
  - [ ] Provide defaults
  - [ ] Log migration actions
  - [ ] Inform user of changes

## Testing

### Step 18: Write Unit Tests
- [ ] Create `tests/test_serialization.cpp`
  - [ ] Test Entity serialization
  - [ ] Test Player serialization
  - [ ] Test Monster serialization
  - [ ] Test Item serialization
  - [ ] Test Inventory serialization
  - [ ] Test Map serialization
- [ ] Test round-trip accuracy
  - [ ] Save → Load → Compare
  - [ ] Verify no data loss
  - [ ] Check all fields preserved

### Step 19: Integration Testing
- [ ] Test full game save/load
  - [ ] Start new game
  - [ ] Play several turns
  - [ ] Save game
  - [ ] Quit and restart
  - [ ] Load game
  - [ ] Verify state restored
- [ ] Test multiple saves
  - [ ] Create multiple saves
  - [ ] Load different saves
  - [ ] Delete saves
- [ ] Test edge cases
  - [ ] Save during combat
  - [ ] Save with inventory open
  - [ ] Save on stairs
  - [ ] Save with full inventory

### Step 20: Error Recovery Testing
- [ ] Test corrupted saves
  - [ ] Truncate save file
  - [ ] Corrupt JSON syntax
  - [ ] Remove required fields
  - [ ] Verify graceful handling
- [ ] Test missing files
  - [ ] Delete save file
  - [ ] Try to load
  - [ ] Verify error message
- [ ] Test permission issues
  - [ ] Make saves directory read-only
  - [ ] Try to save
  - [ ] Verify error handling

### Step 21: Performance Testing
- [ ] Measure save time
  - [ ] Time full save operation
  - [ ] Ensure < 500ms
  - [ ] Profile if too slow
- [ ] Measure load time
  - [ ] Time full load operation
  - [ ] Ensure < 1 second
  - [ ] Optimize if needed
- [ ] Test with large game states
  - [ ] Many entities
  - [ ] Full inventory
  - [ ] Large map
  - [ ] Verify performance

## Documentation

### Step 22: Update User Documentation
- [ ] Update README with save/load instructions
- [ ] Document keybindings
- [ ] Explain save slots
- [ ] Document auto-save behavior
- [ ] Add troubleshooting section

### Step 23: Code Documentation
- [ ] Document serialization format
- [ ] Document version migration
- [ ] Add usage examples
- [ ] Document error codes
- [ ] Update API documentation

## Build and CMake

### Step 24: Update Build System
- [ ] Add new source files to CMakeLists.txt
  - [ ] game_serializer.cpp
  - [ ] save_menu.cpp
- [ ] Update test CMakeLists.txt
  - [ ] Add test_serialization.cpp
- [ ] Verify all dependencies included

## Code Review Checklist

### Before Committing
- [ ] All tests pass
- [ ] No compiler warnings
- [ ] Save/load works correctly
- [ ] Error handling works
- [ ] UI is intuitive
- [ ] No memory leaks
- [ ] Code follows project style
- [ ] Documentation complete

### Final Validation
- [ ] Can save at any game state
- [ ] Can load and continue playing
- [ ] Multiple saves work correctly
- [ ] Quick save/load works
- [ ] Auto-save works if enabled
- [ ] Errors handled gracefully
- [ ] Performance acceptable
- [ ] Version migration works

## Git Operations
- [ ] Stage all changes: `git add -A`
- [ ] Commit: `git commit -m "[Phase 12.1] Implement game serialization"`
- [ ] Tag: `git tag v0.12.1-serialization`
- [ ] Push: `git push && git push --tags`

## Time Tracking

### Estimated vs Actual
- Serializable interface: 1 hour
- GameSerializer class: 2 hours
- Entity serialization: 2 hours
- Map serialization: 2 hours
- Save/Load UI: 2 hours
- Testing: 2 hours
- Documentation: 1 hour
- **Total Estimated**: 12 hours
- **Actual**: ___

## Potential Issues & Solutions

### 1. Large Save Files
**Issue**: Saves might become too large with big maps
**Solution**: Implement compression, store only changes from default

### 2. Save Compatibility
**Issue**: Future versions might break saves
**Solution**: Robust versioning and migration system

### 3. Circular References
**Issue**: Entities might reference each other
**Solution**: Use IDs instead of pointers, rebuild references on load

### 4. Performance Impact
**Issue**: Saving might cause game stutters
**Solution**: Implement async saving in background thread

### 5. Data Validation
**Issue**: Loaded data might be invalid
**Solution**: Comprehensive validation after deserialization

## Dependencies to Verify
- [x] nlohmann/json library available
- [x] File system access working
- [x] Game state is stable
- [x] All entities have unique IDs

## Notes Section
_Use this space during implementation:_

---

## Quick Testing Commands
```bash
# Build and test serialization
./build.sh clean && ./build.sh build && ./build.sh test "[serialization]"

# Test save/load manually
./build.sh run
# Press 'S' to save, 'L' to load, F5 for quick save, F9 for quick load

# Check save files
ls -la saves/
cat saves/save_0.sav | jq '.'

# Test save file corruption handling
echo "corrupted" > saves/save_test.sav
./build.sh run  # Try to load corrupted save
```