# Phase 6.2: Visibility System

## Overview

Phase 6.2 enhances the visibility system to properly integrate FOV with the game's rendering, ensuring that explored areas remain partially visible (as memory) and that visibility updates efficiently during gameplay.

## Current State

### What Already Exists (from Phase 6.1)

1. **FOV Calculation**
   - Raycasting-based FOV algorithm
   - 10-tile default sight radius
   - Line-of-sight blocking by walls
   - Transparent vs opaque tile handling

2. **MapMemory System**
   - Tracks explored tiles
   - Remembers tile contents
   - Three visibility states (UNKNOWN, REMEMBERED, VISIBLE)
   - Updates on FOV calculation

3. **Basic Integration**
   - FOV updates in GameManager
   - Map visibility flags set
   - Renderer uses visibility for display

## Requirements

### Core Functionality

1. **Enhanced Visibility Rendering**
   - [ ] Different visual styles for visibility states
   - [ ] Dimmed/grayed remembered tiles
   - [ ] Black/empty unknown tiles
   - [ ] Full color for visible tiles
   - [ ] Smooth transitions between states

2. **Entity Visibility**
   - [ ] Hide monsters in non-visible areas
   - [ ] Hide items in non-visible areas
   - [ ] Show remembered positions (optional)
   - [ ] Update entity visibility on FOV change

3. **Performance Optimization**
   - [ ] Only update changed tiles
   - [ ] Batch visibility updates
   - [ ] Minimize redundant calculations
   - [ ] Efficient memory access patterns

4. **Special Cases**
   - [ ] Handle door opening/closing visibility changes
   - [ ] Support always-visible tiles (magical light)
   - [ ] Handle teleportation visibility updates
   - [ ] Support vision-affecting status effects

## Implementation Tasks

### 1. Enhanced Renderer Integration

```cpp
class MapRenderer {
    struct RenderStyle {
        float brightness;     // 0.0 to 1.0
        bool showEntities;   // Whether to render entities
        Color tint;          // Color modification
        bool showDetails;    // Whether to show tile details
    };
    
    RenderStyle getStyleForVisibility(MapMemory::VisibilityState state) {
        switch(state) {
            case MapMemory::VisibilityState::VISIBLE:
                return {1.0f, true, Color::White, true};
            case MapMemory::VisibilityState::REMEMBERED:
                return {0.5f, false, Color::GrayDark, false};
            case MapMemory::VisibilityState::UNKNOWN:
                return {0.0f, false, Color::Black, false};
        }
    }
};
```

### 2. Entity Visibility System

```cpp
class EntityManager {
    void updateEntityVisibility(const std::vector<std::vector<bool>>& fov) {
        for (auto& entity : entities) {
            entity->setVisible(fov[entity->y][entity->x]);
        }
    }
    
    std::vector<Entity*> getVisibleEntities() const {
        std::vector<Entity*> visible;
        for (const auto& entity : entities) {
            if (entity->isVisible()) {
                visible.push_back(entity.get());
            }
        }
        return visible;
    }
};
```

### 3. Visibility Change Detection

```cpp
class VisibilityTracker {
    std::vector<std::vector<bool>> previousFOV;
    
    struct VisibilityChange {
        Point position;
        bool wasVisible;
        bool isVisible;
    };
    
    std::vector<VisibilityChange> getChanges(
        const std::vector<std::vector<bool>>& newFOV) {
        std::vector<VisibilityChange> changes;
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                if (previousFOV[y][x] != newFOV[y][x]) {
                    changes.push_back({Point(x, y), 
                                     previousFOV[y][x], 
                                     newFOV[y][x]});
                }
            }
        }
        
        previousFOV = newFOV;
        return changes;
    }
};
```

### 4. Rendering Pipeline

```cpp
void GameScreen::render() {
    // 1. Update FOV if player moved
    if (playerMoved) {
        game_manager->updateFOV();
    }
    
    // 2. Get visibility for each tile
    auto memory = game_manager->getMapMemory();
    
    // 3. Render map with visibility
    for (each tile in viewport) {
        auto visibility = memory->getVisibility(x, y);
        auto style = getStyleForVisibility(visibility);
        
        if (visibility == UNKNOWN) {
            renderBlank(x, y);
        } else if (visibility == REMEMBERED) {
            renderTile(x, y, memory->getRemembered(x, y), style);
        } else { // VISIBLE
            renderTile(x, y, map->getTile(x, y), style);
            renderEntitiesAt(x, y);
        }
    }
}
```

## Testing Requirements

### Unit Tests
- [ ] Visibility state transitions
- [ ] Entity visibility updates
- [ ] Memory persistence
- [ ] Change detection accuracy
- [ ] Rendering style application

### Integration Tests
- [ ] Movement updates visibility correctly
- [ ] Doors affect visibility when opened/closed
- [ ] Entities hidden when not visible
- [ ] Memory shows last known state
- [ ] Performance with rapid movement

### Visual Tests
- [ ] Smooth visual transitions
- [ ] Clear distinction between states
- [ ] No flickering or artifacts
- [ ] Appropriate dimming levels

## Files to Modify

1. **src/renderer.cpp**
   - Add visibility-based rendering styles
   - Implement dimming for remembered tiles
   - Hide entities in non-visible areas

2. **src/game_screen.cpp**
   - Integrate visibility into render pipeline
   - Handle visibility state changes

3. **src/entity_manager.cpp**
   - Add entity visibility tracking
   - Filter entities by visibility

4. **include/entity.h**
   - Add visibility flag to Entity base class
   - Add setVisible/isVisible methods

5. **tests/test_visibility.cpp** (new)
   - Unit tests for visibility system
   - Integration tests for rendering

## Dependencies

- Phase 6.1 FOV Algorithm (✅ Complete)
- MapMemory system (✅ Complete)
- Basic rendering system (✅ Complete)
- Entity system (✅ Complete)

## Success Criteria

1. **Visual Clarity**: Clear distinction between visible/remembered/unknown
2. **Performance**: No noticeable lag when updating visibility
3. **Correctness**: Entities only visible when in FOV
4. **Memory**: Previously seen areas remain partially visible
5. **Consistency**: Visibility updates immediately on movement

## Implementation Order

1. First: Enhance renderer with visibility styles
2. Second: Implement entity visibility filtering
3. Third: Add change detection for optimization
4. Fourth: Polish visual transitions and effects

## Future Enhancements

1. **Advanced Visibility Effects**
   - Fog effects for partial visibility
   - Light radius from torches/spells
   - Darkness that blocks even memory
   - X-ray vision through walls

2. **Memory Decay**
   - Gradual fading of remembered areas
   - Forgetting details over time
   - Confusion effects that scramble memory

3. **Shared Vision**
   - Party member shared FOV
   - Pet/familiar vision sharing
   - Scrying/remote viewing

## Notes

- The current renderer already handles basic visibility (visible/explored)
- Need to enhance it to use the full MapMemory system
- Consider color-blind friendly dimming approaches
- Memory should persist between save/load cycles
- Performance is critical - visibility updates every turn