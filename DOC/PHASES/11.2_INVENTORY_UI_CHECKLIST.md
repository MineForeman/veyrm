# Phase 11.2: Inventory UI - Implementation Checklist

## Pre-Implementation Setup
- [x] Review Phase 11.1 inventory storage implementation
- [x] Study existing UI components (game_screen.cpp, renderer.cpp)
- [x] Review FTXUI documentation for component patterns
- [x] Plan UI layout and interactions

## Core Implementation

### Step 1: Create Inventory Screen Component
- [x] Create `include/inventory_renderer.h` (used renderer pattern instead)
  - [x] Define InventoryRenderer class
  - [x] Not ComponentBase (follows existing pattern)
  - [x] Add member variables for state
  - [x] Declare public interface
- [x] Create `src/inventory_renderer.cpp`
  - [x] Implement constructor
  - [x] Set up initial state
  - [x] Initialize with player pointer

### Step 2: Implement Basic Rendering
- [x] Implement `render()` method
  - [x] Create main container layout
  - [x] Add title bar with slot count
  - [x] Create item list panel
  - [x] Add empty slot placeholders
- [x] Test basic rendering
  - [x] Verify layout structure
  - [x] Check text alignment
  - [x] Ensure proper borders

### Step 3: Display Inventory Items
- [x] Implement `renderItemList()`
  - [x] Iterate through inventory slots
  - [x] Format item names with padding
  - [x] Show stack counts for stackable items
  - [x] Display weight per item
  - [x] Add slot letters (a-z)
- [x] Handle empty slots
  - [x] Show "[empty]" with dim styling
  - [x] Maintain consistent formatting
- [x] Add color coding
  - [x] Weapons: cyan
  - [x] Armor: blue
  - [x] Potions: magenta
  - [x] Scrolls: yellow
  - [x] Gold: bold yellow

### Step 4: Add Selection System
- [x] Track selected slot index
- [x] Implement selection highlighting
  - [x] Use inverted colors for selected item
  - [x] Update on navigation
- [x] Add `getSelectedItem()` method
- [x] Handle selection bounds
  - [x] Clamp to valid range
  - [x] Handle empty inventory

### Step 5: Implement Navigation
- [x] Navigation handled in GameScreen
  - [x] Handle arrow keys (up/down)
  - [x] Handle letter keys (a-z) for direct selection
  - [x] Handle Page Up/Down for scrolling (prepared)
- [x] Implement scroll offset
  - [x] Track current scroll position
  - [x] Calculate visible window
  - [x] Update rendering to use offset
- [x] Add navigation helpers
  - [x] `selectNext()`
  - [x] `selectPrevious()`
  - [x] `selectSlot(int slot)`

### Step 6: Add Item Details Panel
- [x] Implement `renderItemDetails()`
  - [x] Show selected item name
  - [x] Display item type
  - [x] Show weight and value
  - [x] Add description text
- [x] Handle no selection
  - [x] Show placeholder text
  - [x] Clear details panel
- [x] Format properties
  - [x] Align labels and values
  - [x] Use consistent spacing

### Step 7: Implement Action Bar
- [x] Create `renderActionBar()` method
  - [x] Show available actions
  - [x] Highlight action keys
  - [x] Include ESC for close
- [x] Update based on item type
  - [x] Show "use" for consumables
  - [ ] Show "equip" for equipment (future)
  - [x] Conditionally show actions

### Step 8: Add Input Handling
- [x] Update `include/input_handler.h`
  - [x] Verify OPEN_INVENTORY exists
  - [x] Add USE_ITEM action
  - [x] Add DROP_ITEM action
  - [x] Add EXAMINE_ITEM action
- [x] Update `src/input_handler.cpp`
  - [x] Map 'i' to OPEN_INVENTORY
  - [x] Map 'u' to USE_ITEM
  - [x] Map 'D' to DROP_ITEM (uppercase)
  - [x] Map 'E' to EXAMINE_ITEM (uppercase)

### Step 9: Integrate with Game Screen
- [x] Update `src/game_screen.cpp`
  - [x] Add InventoryRenderer member
  - [x] Handle OPEN_INVENTORY action
  - [x] Switch to INVENTORY state
  - [x] Preserve previous state
- [x] Handle inventory state
  - [x] Route input to inventory handler
  - [x] Render inventory instead of game
  - [x] Handle close/escape
- [x] Manage focus
  - [x] Disable game input when inventory open
  - [x] Restore focus on close

### Step 10: Implement Use Action
- [x] Create `handleInventoryInput()` with USE_ITEM
  - [x] Get selected item
  - [x] Check if usable
  - [x] Apply item effects
- [x] Handle potions
  - [x] Apply healing
  - [x] Remove from inventory
  - [x] Show message
  - [x] Close inventory
- [x] Handle non-usable items
  - [x] Show "can't use" message
  - [x] Keep inventory open

### Step 11: Implement Drop Action
- [x] Implement DROP_ITEM in handleInventoryInput
  - [x] Remove item from inventory
  - [x] Get player position
  - [x] Spawn item in world
- [x] Update ItemManager
  - [x] Add item at position
  - [x] Items appear on map after drop
- [x] Show feedback
  - [x] Add drop message
  - [x] Update display immediately
  - [x] Keep inventory open

### Step 12: Implement Examine Action
- [x] Implement EXAMINE_ITEM in handleInventoryInput
  - [x] Get detailed item info
  - [x] Show extended description
  - [x] Display all properties
- [x] Show in message log
  - [x] Item name and description
  - [x] Special properties
  - [ ] Modal overlay (not needed)

### Step 13: Add Status Bar
- [x] Show inventory statistics
  - [x] Used/total slots
  - [x] Total weight
  - [x] Gold count
- [x] Update dynamically
  - [x] Refresh on changes
  - [x] Show current values

### Step 14: Polish UI
- [x] Add separators between panels
- [x] Ensure consistent spacing
- [ ] Add subtle animations (skipped)
  - [ ] Fade in/out
  - [ ] Smooth scrolling
- [x] Test different terminal sizes
  - [x] Handle small terminals
  - [x] Adjust layout as needed

## Testing

### Step 15: Write Unit Tests
- [ ] Create `tests/test_inventory_screen.cpp` (manual testing done)
- [x] Test component creation (manual)
- [x] Test state management (manual)
  - [x] Open/close states
  - [x] Selection tracking
  - [x] Scroll position
- [x] Test navigation (manual)
  - [x] Arrow key movement
  - [x] Direct slot selection
  - [x] Bounds checking
- [x] Test actions (manual)
  - [x] Use item
  - [x] Drop item
  - [x] Examine item

### Step 16: Integration Testing
- [x] Test with empty inventory
- [x] Test with full inventory
- [x] Test with various item types
- [x] Test stacked items display
- [x] Test weight calculations
- [x] Test message log updates
- [x] Verify turn consumption (use=normal, drop=fast)

### Step 17: Manual Testing
- [x] Open inventory with 'i'
- [x] Navigate with all input methods
- [x] Use consumable items
- [x] Drop items and verify placement
- [x] Examine different item types
- [x] Close with ESC and 'i'
- [x] Test edge cases
  - [x] Spam inputs
  - [x] Rapid open/close
  - [x] Use last item

## Documentation

### Step 18: Update Documentation
- [ ] Update controls in README
- [ ] Document inventory shortcuts
- [ ] Add UI screenshots (if applicable)
- [ ] Update IMPLEMENTATION_PLAN.md

### Step 19: Code Documentation
- [ ] Add class documentation
- [ ] Document public methods
- [ ] Explain complex rendering logic
- [ ] Add usage examples

## Build and CMake

### Step 20: Update Build System
- [x] Add `src/inventory_renderer.cpp` to CMakeLists.txt
- [x] Update test CMakeLists.txt if needed
- [x] Verify all dependencies included

## Code Review Checklist

### Before Committing
- [x] All tests pass
- [x] No compiler warnings
- [x] UI renders correctly
- [x] Navigation works smoothly
- [x] Actions function properly
- [x] No memory leaks
- [x] Code follows project style

### Final Validation
- [x] Inventory opens/closes properly
- [x] Items display with correct formatting
- [x] Selection highlighting works
- [x] All actions functional
- [x] Messages display correctly
- [x] No visual glitches
- [x] Performance acceptable

## Git Operations
- [ ] Stage all changes: `git add -A`
- [ ] Commit: `git commit -m "[Phase 11.2] Implement inventory UI"`
- [ ] Tag: `git tag v0.11.2-inventory-ui`
- [ ] Push: `git push && git push --tags`

## Time Estimate
- UI Component: 2-3 hours
- Navigation: 1-2 hours
- Actions: 1-2 hours
- Testing: 1-2 hours
- Polish: 1 hour
- Total: ~7-10 hours

## Potential Issues
1. **FTXUI component complexity** - Study existing patterns
2. **State management** - Keep state synchronized
3. **Focus handling** - Proper input routing
4. **Terminal compatibility** - Test various terminals
5. **Performance with scrolling** - Implement viewport

## Dependencies to Verify
- [ ] Phase 11.1 complete and working
- [ ] FTXUI component system understood
- [ ] Input handler extensible
- [ ] Game state management flexible

## Notes Section
_Use this space during implementation:_

---

## Quick Testing Commands
```bash
# Build and run
./build.sh clean && ./build.sh build && ./build.sh run

# Test inventory with items spawned
./build.sh run --debug

# Run specific tests
./build/bin/veyrm_tests "[inventory_screen]"

# Check for memory leaks
valgrind --leak-check=full ./build/bin/veyrm
```