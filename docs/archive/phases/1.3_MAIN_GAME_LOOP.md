# Phase 1.3: Main Game Loop

## Overview

Implement a proper game loop that cleanly separates input processing, game state updates, and rendering. This establishes the foundation for consistent frame timing, smooth gameplay, and proper separation of concerns.

## Current State Analysis

### What We Have

- ✅ **FTXUI Event Loop**: Currently using FTXUI's built-in loop via `ScreenInteractive::Loop()`
- ✅ **Input Handling**: InputHandler class processes keyboard events
- ✅ **Turn System**: TurnManager handles turn-based progression
- ✅ **State Management**: GameManager tracks game states
- ✅ **Rendering**: FTXUI components handle rendering

### What's Missing

- ❌ **Fixed Timestep**: No frame rate control or consistent timing
- ❌ **Update/Render Separation**: Logic and rendering are coupled
- ❌ **Delta Time**: No time-based updates for animations
- ❌ **Performance Monitoring**: No FPS counter or frame timing
- ❌ **Pause Handling**: Pause state doesn't properly halt game updates

## Technical Requirements

### 1. Game Loop Architecture

```cpp
class GameLoop {
public:
    void run();
    void stop();
    void setTargetFPS(int fps);
    
private:
    void processInput();
    void update(double deltaTime);
    void render();
    void limitFrameRate();
    
    bool running;
    int targetFPS = 60;
    double accumulator = 0.0;
    double fixedTimeStep = 1.0/60.0;
};
```

### 2. Frame Timing System

- **Fixed Timestep**: 60 FPS target (16.67ms per frame)
- **Frame Limiting**: Sleep to maintain consistent frame rate
- **Delta Time**: Track time between frames for smooth updates
- **Accumulator**: Handle variable frame times with fixed logic updates

### 3. Update/Render Separation

```
┌─────────────┐
│   Input     │ ← Process all pending events
└──────┬──────┘
       │
┌──────▼──────┐
│   Update    │ ← Fixed timestep logic updates
└──────┬──────┘
       │
┌──────▼──────┐
│   Render    │ ← Draw current state
└──────┬──────┘
       │
┌──────▼──────┐
│ Frame Limit │ ← Sleep if needed
└─────────────┘
```

## Implementation Details

### 1. Core Loop Structure

```cpp
void GameLoop::run() {
    auto previousTime = std::chrono::steady_clock::now();
    
    while (running) {
        auto currentTime = std::chrono::steady_clock::now();
        double frameTime = std::chrono::duration<double>(
            currentTime - previousTime).count();
        previousTime = currentTime;
        
        // Prevent spiral of death
        frameTime = std::min(frameTime, 0.25);
        
        accumulator += frameTime;
        
        // Process input once per frame
        processInput();
        
        // Fixed timestep updates
        while (accumulator >= fixedTimeStep) {
            update(fixedTimeStep);
            accumulator -= fixedTimeStep;
        }
        
        // Render at actual frame rate
        render();
        
        // Limit frame rate
        limitFrameRate();
    }
}
```

### 2. Integration with FTXUI

Since FTXUI has its own event loop, we need to:

- Option A: Replace FTXUI's loop with custom loop (complex)
- Option B: Use FTXUI's animation features with callbacks
- Option C: Run game logic in separate thread with event posting

**Recommended: Option B** - Use FTXUI's Loop with periodic callbacks

```cpp
auto game_loop = Container::Vertical({});

// Add animation component for frame updates
game_loop |= CatchEvent([&](Event event) {
    if (event == Event::Custom) {
        updateGameLogic();
        return true;
    }
    return inputHandler->processEvent(event);
});

// Post custom events at fixed intervals
std::thread timer_thread([&screen]() {
    while (running) {
        std::this_thread::sleep_for(16ms);
        screen.PostEvent(Event::Custom);
    }
});
```

### 3. Performance Monitoring

```cpp
class FrameStats {
    double fps;
    double frameTime;
    double updateTime;
    double renderTime;
    
    void update();
    std::string format() const;
};
```

### 4. Pause System Enhancement

```cpp
void GameLoop::update(double dt) {
    if (gameManager->getState() == GameState::PAUSED) {
        // Skip logic updates but continue rendering
        return;
    }
    
    // Normal updates
    turnManager->update(dt);
    // Future: animations, particles, etc.
}
```

## Implementation Checklist

### Core Components

- [ ] Create GameLoop class
- [ ] Implement frame timing system
- [ ] Add fixed timestep updates
- [ ] Implement frame rate limiting
- [ ] Add delta time tracking

### FTXUI Integration

- [ ] Create animation component
- [ ] Set up periodic event posting
- [ ] Integrate with existing components
- [ ] Handle thread synchronization
- [ ] Clean shutdown mechanism

### Performance Monitoring

- [ ] Add FPS counter
- [ ] Track frame times
- [ ] Add debug overlay option
- [ ] Log performance warnings

### State Management

- [ ] Enhance pause handling
- [ ] Prevent updates during menus
- [ ] Handle state transitions cleanly
- [ ] Add frame-skip for slow systems

### Testing

- [ ] Test consistent frame rate
- [ ] Verify pause stops updates
- [ ] Check memory usage over time
- [ ] Test with automated input
- [ ] Stress test with many entities

## File Structure

```
include/
  game_loop.h      # Main loop class
  frame_stats.h    # Performance monitoring
  
src/
  game_loop.cpp    # Loop implementation
  frame_stats.cpp  # Stats tracking
  main.cpp         # Integration point
```

## Integration Points

### main.cpp Changes

- Create GameLoop instance
- Pass GameManager to loop
- Start loop instead of screen.Loop()
- Handle shutdown cleanly

### GameManager Changes

- Add update(dt) method
- Separate logic from rendering
- Add performance stats access

### Component Changes

- Remove logic from Render()
- Move updates to update() methods
- Keep rendering lightweight

## Success Criteria

1. **Stable 60 FPS**: Game maintains target frame rate
2. **Smooth Updates**: No stuttering or irregular timing
3. **Clean Separation**: Logic and rendering are independent
4. **Pause Works**: Game state freezes when paused
5. **Performance Visible**: FPS counter shows in debug mode
6. **Resource Efficient**: CPU usage reasonable when idle

## Potential Challenges

### Thread Safety

- FTXUI components accessed from multiple threads
- Need mutex for shared state
- Event queue synchronization

### Platform Differences

- Sleep precision varies by OS
- High-resolution timers availability
- Terminal refresh rates

### FTXUI Limitations

- Built for reactive UI, not game loops
- May need custom modifications
- Event system overhead

## Alternative Approaches

### 1. Pure FTXUI Animation

Use FTXUI's animation system entirely:

```cpp
auto animator = animation::Loop(16ms, [&]() {
    updateGameLogic();
    return true;
});
```

### 2. External Loop

Run game loop separately and push frames:

```cpp
while (running) {
    update();
    Element frame = render();
    screen.PostEvent(Event::Custom(frame));
}
```

### 3. Hybrid Approach

Keep FTXUI for UI, custom loop for game:

- Menu uses FTXUI loop
- Game uses custom loop
- Switch between them

## Testing Strategy

### Manual Tests

1. Run game and observe FPS counter
2. Test pause/unpause repeatedly
3. Hold movement keys for smooth motion
4. Switch between states rapidly
5. Leave running for extended period

### Automated Tests

1. Use --dump mode to verify consistent updates
2. Measure frame times programmatically
3. Stress test with rapid inputs
4. Check memory usage over time

### Performance Benchmarks

- Target: 60 FPS consistently
- Update time: < 5ms
- Render time: < 10ms
- Memory: Stable over 1 hour

## Next Steps

After completing Phase 1.3:

- Phase 2.1: Tile System (build on update loop)
- Phase 2.2: Map Rendering (optimize with loop)
- Phase 2.3: Simple Test Map (test performance)

## References

- [Game Programming Patterns - Game Loop](https://gameprogrammingpatterns.com/game-loop.html)
- [Fix Your Timestep](https://gafferongames.com/post/fix_your_timestep/)
- [FTXUI Animation Docs](https://github.com/ArthurSonzogni/FTXUI/blob/main/examples/component/animation.cpp)
