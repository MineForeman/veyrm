# Phase 0.2: Dependencies Setup - Detailed Implementation Guide

## Overview

This phase integrates the three core dependencies for the Veyrm roguelike:
1. **FTXUI** - Terminal UI framework for rendering
2. **nlohmann/json** - JSON parsing for game data and saves
3. **Catch2** - Testing framework for unit tests

By the end of this phase, we'll have a simple FTXUI window with a quit function and basic tests running.

## Prerequisites

- Phase 0.1 completed successfully
- CMake 3.25+ installed
- Internet connection for FetchContent downloads
- Git for dependency fetching

## Dependencies Overview

| Library | Version | Purpose | Size |
|---------|---------|---------|------|
| FTXUI | v5.0.0 | Terminal UI rendering | ~2MB |
| nlohmann/json | v3.11.3 | JSON parsing | ~1MB |
| Catch2 | v3.5.1 | Unit testing | ~3MB |

## Step-by-Step Implementation

### Step 1: Update CMakeLists.txt with FetchContent

Replace the current `CMakeLists.txt` with dependency management:

```cmake
cmake_minimum_required(VERSION 3.25)

# Project definition
project(veyrm 
    VERSION 0.0.2
    DESCRIPTION "Modern C++ Roguelike inspired by Angband"
    LANGUAGES CXX
)

# C++ Standard
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Export compile commands for IDE integration
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Build type configuration
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Debug" CACHE STRING "Build type" FORCE)
endif()

message(STATUS "========================================")
message(STATUS "Veyrm Build Configuration")
message(STATUS "========================================")
message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
message(STATUS "C++ Standard: ${CMAKE_CXX_STANDARD}")
message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")

# ========================================
# FetchContent for dependencies
# ========================================
include(FetchContent)

# Set FetchContent to be quieter
set(FETCHCONTENT_QUIET ON)

# FTXUI
message(STATUS "Configuring FTXUI...")
FetchContent_Declare(
    ftxui
    GIT_REPOSITORY https://github.com/ArthurSonzogni/FTXUI.git
    GIT_TAG v5.0.0
    GIT_SHALLOW TRUE
)

# nlohmann/json
message(STATUS "Configuring nlohmann/json...")
FetchContent_Declare(
    json
    GIT_REPOSITORY https://github.com/nlohmann/json.git
    GIT_TAG v3.11.3
    GIT_SHALLOW TRUE
)

# Catch2
message(STATUS "Configuring Catch2...")
FetchContent_Declare(
    Catch2
    GIT_REPOSITORY https://github.com/catchorg/Catch2.git
    GIT_TAG v3.5.1
    GIT_SHALLOW TRUE
)

# Make dependencies available
FetchContent_MakeAvailable(ftxui json Catch2)

message(STATUS "All dependencies configured successfully")

# ========================================
# Compiler configuration
# ========================================
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(
        -Wall
        -Wextra
        -Wpedantic
        -Werror
        $<$<CONFIG:Debug>:-g>
        $<$<CONFIG:Debug>:-O0>
        $<$<CONFIG:Debug>:-fsanitize=address>
        $<$<CONFIG:Release>:-O3>
        $<$<CONFIG:Release>:-DNDEBUG>
    )
    # Link sanitizer in debug mode
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        add_link_options(-fsanitize=address)
    endif()
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    add_compile_options(
        /W4
        /WX
        $<$<CONFIG:Debug>:/Od>
        $<$<CONFIG:Debug>:/RTC1>
        $<$<CONFIG:Release>:/O2>
    )
    # UTF-8 support for MSVC
    add_compile_options(/utf-8)
endif()

# Platform-specific definitions
if(WIN32)
    add_compile_definitions(PLATFORM_WINDOWS)
    # Windows specific FTXUI color fix
    add_compile_definitions(FTXUI_MICROSOFT_TERMINAL_FALLBACK_COLORS)
elseif(APPLE)
    add_compile_definitions(PLATFORM_MACOS)
elseif(UNIX)
    add_compile_definitions(PLATFORM_LINUX)
endif()

# ========================================
# Include directories
# ========================================
include_directories(${CMAKE_SOURCE_DIR}/include)

# ========================================
# Main executable
# ========================================
add_executable(veyrm src/main.cpp)

# Link libraries
target_link_libraries(veyrm 
    PRIVATE 
        ftxui::screen
        ftxui::dom
        ftxui::component
        nlohmann_json::nlohmann_json
)

# Set executable output directory
set_target_properties(veyrm PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)

# ========================================
# Testing
# ========================================
enable_testing()
add_subdirectory(tests)

# ========================================
# Installation rules
# ========================================
install(TARGETS veyrm DESTINATION bin)
install(DIRECTORY data/ DESTINATION share/veyrm/data)

# ========================================
# Configuration summary
# ========================================
message(STATUS "========================================")
message(STATUS "Veyrm Configuration Summary:")
message(STATUS "  Version: ${PROJECT_VERSION}")
message(STATUS "  Install prefix: ${CMAKE_INSTALL_PREFIX}")
message(STATUS "  Executable: ${CMAKE_BINARY_DIR}/bin/veyrm")
message(STATUS "  Dependencies:")
message(STATUS "    - FTXUI: v5.0.0")
message(STATUS "    - nlohmann/json: v3.11.3")
message(STATUS "    - Catch2: v3.5.1")
message(STATUS "========================================")
```

### Step 2: Create Basic FTXUI Application

Update `src/main.cpp` to use FTXUI:

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <vector>

// FTXUI includes
#include <ftxui/component/captured_mouse.hpp>
#include <ftxui/component/component.hpp>
#include <ftxui/component/component_base.hpp>
#include <ftxui/component/screen_interactive.hpp>
#include <ftxui/dom/elements.hpp>

// JSON include
#include <nlohmann/json.hpp>

// Platform-specific includes for UTF-8 support
#ifdef PLATFORM_WINDOWS
    #include <windows.h>
    #include <io.h>
    #include <fcntl.h>
#endif

// Version information
constexpr const char* VEYRM_VERSION = "0.0.2";
constexpr const char* VEYRM_BUILD_DATE = __DATE__;

/**
 * Initialize platform-specific settings
 */
void initializePlatform() {
#ifdef PLATFORM_WINDOWS
    // Enable UTF-8 support on Windows
    SetConsoleCP(CP_UTF8);
    SetConsoleOutputCP(CP_UTF8);
    _setmode(_fileno(stdout), _O_U8TEXT);
#endif
    
    // Set locale for proper Unicode handling
    std::locale::global(std::locale(""));
}

/**
 * Test JSON functionality
 */
bool testJsonLibrary() {
    try {
        // Create a simple JSON object
        nlohmann::json testData = {
            {"version", VEYRM_VERSION},
            {"test", true},
            {"entities", {"player", "monster", "item"}}
        };
        
        // Serialize to string
        std::string jsonStr = testData.dump();
        
        // Parse back
        auto parsed = nlohmann::json::parse(jsonStr);
        
        return parsed["test"] == true;
    } catch (const std::exception& e) {
        std::cerr << "JSON test failed: " << e.what() << std::endl;
        return false;
    }
}

/**
 * Run system checks with dependencies
 */
bool runSystemChecks() {
    bool allPassed = true;
    
    std::cout << "Running system checks...\n";
    
    // Check C++ version
    std::cout << "  [";
    if (__cplusplus >= 202302L) {
        std::cout << "✓";
    } else {
        std::cout << "✗";
        allPassed = false;
    }
    std::cout << "] C++23 support\n";
    
    // Check JSON library
    std::cout << "  [";
    if (testJsonLibrary()) {
        std::cout << "✓";
    } else {
        std::cout << "✗";
        allPassed = false;
    }
    std::cout << "] nlohmann/json library\n";
    
    // Check FTXUI (basic check)
    std::cout << "  [✓] FTXUI library (will test in UI mode)\n";
    
    // Check terminal
    std::cout << "  [✓] Terminal output\n";
    
    std::cout << "\n";
    return allPassed;
}

/**
 * Create the main menu component
 */
ftxui::Component createMainMenu() {
    using namespace ftxui;
    
    // Menu state
    static int selected = 0;
    static bool show_about = false;
    
    auto screen = ScreenInteractive::Fullscreen();
    
    // Menu options
    std::vector<std::string> menu_entries = {
        "New Game",
        "Continue",
        "Settings",
        "About",
        "Quit"
    };
    
    auto menu = Menu(&menu_entries, &selected);
    
    // Main container
    auto component = Container::Vertical({
        menu,
    });
    
    // Handle menu selection
    component |= CatchEvent([&](Event event) {
        if (event == Event::Return) {
            switch(selected) {
                case 0: // New Game
                    screen.Post(Event::Custom);
                    break;
                case 1: // Continue
                    screen.Post(Event::Custom);
                    break;
                case 2: // Settings
                    break;
                case 3: // About
                    show_about = !show_about;
                    break;
                case 4: // Quit
                    screen.ExitLoopClosure()();
                    break;
            }
            return true;
        }
        if (event == Event::Character('q') || event == Event::Escape) {
            screen.ExitLoopClosure()();
            return true;
        }
        return false;
    });
    
    // Renderer
    auto renderer = Renderer(component, [&] {
        // Title
        auto title = vbox({
            text("╔══════════════════════════════════════╗") | color(Color::Yellow),
            text("║         VEYRM ROGUELIKE              ║") | color(Color::Yellow),
            text("║     The Shattered Crown Awaits       ║") | color(Color::Yellow),
            text("╚══════════════════════════════════════╝") | color(Color::Yellow),
            separator(),
        });
        
        // Menu
        auto menu_display = vbox({
            text("Main Menu") | bold,
            separator(),
            menu->Render(),
        }) | border | size(WIDTH, EQUAL, 30);
        
        // About box (conditional)
        Element about_box = emptyElement();
        if (show_about) {
            about_box = vbox({
                separator(),
                window(text("About"), vbox({
                    text("Version: " + std::string(VEYRM_VERSION)),
                    text("Build Date: " + std::string(VEYRM_BUILD_DATE)),
                    separator(),
                    text("A modern roguelike inspired by Angband"),
                    text("Built with FTXUI, C++23"),
                    separator(),
                    text("Press ESC or Q to quit"),
                })),
            });
        }
        
        // Status line
        auto status = hbox({
            text("Use ↑↓ to navigate, Enter to select, Q to quit") | dim,
        });
        
        // Combine all elements
        return vbox({
            title,
            flex(vbox({
                menu_display,
                about_box,
            })) | center,
            separator(),
            status,
        });
    });
    
    return renderer;
}

/**
 * Run FTXUI interface
 */
void runInterface() {
    using namespace ftxui;
    
    auto screen = ScreenInteractive::Fullscreen();
    auto main_menu = createMainMenu();
    
    screen.Loop(main_menu);
    
    std::cout << "Thanks for playing Veyrm!\n";
}

/**
 * Main entry point
 */
int main(int argc, char* argv[]) {
    // Initialize platform-specific settings
    initializePlatform();
    
    // Handle command-line arguments
    if (argc > 1) {
        std::string arg = argv[1];
        if (arg == "--version" || arg == "-v") {
            std::cout << "veyrm version " << VEYRM_VERSION << "\n";
            std::cout << "Dependencies:\n";
            std::cout << "  - FTXUI v5.0.0\n";
            std::cout << "  - nlohmann/json v3.11.3\n";
            std::cout << "  - Catch2 v3.5.1\n";
            return 0;
        } else if (arg == "--help" || arg == "-h") {
            std::cout << "Usage: " << argv[0] << " [options]\n";
            std::cout << "Options:\n";
            std::cout << "  -h, --help     Show this help message\n";
            std::cout << "  -v, --version  Show version information\n";
            std::cout << "  --test         Run system checks\n";
            std::cout << "  --no-ui        Run without UI (test mode)\n";
            return 0;
        } else if (arg == "--test") {
            bool passed = runSystemChecks();
            if (passed) {
                std::cout << "All system checks passed! ✓\n";
                std::cout << "Phase 0.2: Dependencies Setup - COMPLETE ✓\n";
                return 0;
            } else {
                std::cout << "Some checks failed. Please review the requirements.\n";
                return 1;
            }
        } else if (arg == "--no-ui") {
            std::cout << "Running in no-UI mode...\n";
            bool passed = runSystemChecks();
            std::cout << "Dependencies test " << (passed ? "PASSED" : "FAILED") << "\n";
            return passed ? 0 : 1;
        }
    }
    
    // Run the interface
    runInterface();
    
    return 0;
}
```

### Step 3: Create Test Configuration

Update `tests/CMakeLists.txt`:

```cmake
# Tests configuration with Catch2

# Create test executable
add_executable(veyrm_tests
    test_main.cpp
    test_json.cpp
    test_basic.cpp
)

# Link with Catch2 and other dependencies
target_link_libraries(veyrm_tests
    PRIVATE
        Catch2::Catch2WithMain
        nlohmann_json::nlohmann_json
)

# Add compile definitions for tests
target_compile_definitions(veyrm_tests PRIVATE
    TESTING_MODE
)

# Register tests with CTest
include(CTest)
include(Catch)
catch_discover_tests(veyrm_tests)

# Set test output directory
set_target_properties(veyrm_tests PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)

message(STATUS "Tests configured with Catch2")
```

### Step 4: Create Test Files

Create `tests/test_main.cpp`:

```cpp
// This file is intentionally empty as we use Catch2WithMain
// which provides its own main function
```

Create `tests/test_json.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <nlohmann/json.hpp>
#include <string>

using json = nlohmann::json;

TEST_CASE("JSON library basic functionality", "[json]") {
    SECTION("Create and parse JSON") {
        json j = {
            {"name", "Veyrm"},
            {"version", "0.0.2"},
            {"features", {"roguelike", "terminal", "json"}}
        };
        
        REQUIRE(j["name"] == "Veyrm");
        REQUIRE(j["version"] == "0.0.2");
        REQUIRE(j["features"].size() == 3);
    }
    
    SECTION("Serialize and deserialize") {
        json original = {
            {"hp", 100},
            {"attack", 10},
            {"defense", 5}
        };
        
        std::string serialized = original.dump();
        json parsed = json::parse(serialized);
        
        REQUIRE(parsed["hp"] == 100);
        REQUIRE(parsed["attack"] == 10);
        REQUIRE(parsed["defense"] == 5);
    }
    
    SECTION("Handle game data structures") {
        json monster = {
            {"id", "gutter_rat"},
            {"glyph", "r"},
            {"color", "grey"},
            {"hp", 3},
            {"atk", {1, 3}},
            {"def", 0},
            {"speed", 100}
        };
        
        REQUIRE(monster["id"] == "gutter_rat");
        REQUIRE(monster["hp"] == 3);
        REQUIRE(monster["atk"][0] == 1);
        REQUIRE(monster["atk"][1] == 3);
    }
}

TEST_CASE("JSON error handling", "[json]") {
    SECTION("Invalid JSON throws exception") {
        std::string invalid = "{invalid json}";
        REQUIRE_THROWS_AS(json::parse(invalid), json::parse_error);
    }
    
    SECTION("Missing keys return null") {
        json j = {{"exists", true}};
        REQUIRE(j["missing"].is_null());
    }
}
```

Create `tests/test_basic.cpp`:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <string>
#include <vector>

TEST_CASE("Basic C++ functionality", "[basic]") {
    SECTION("String operations") {
        std::string game = "Veyrm";
        REQUIRE(game.length() == 5);
        REQUIRE(game[0] == 'V');
    }
    
    SECTION("Vector operations") {
        std::vector<int> hp_values = {10, 20, 30};
        REQUIRE(hp_values.size() == 3);
        REQUIRE(hp_values[1] == 20);
    }
    
    SECTION("UTF-8 string handling") {
        std::string walls = "═║╔╗╚╝";
        REQUIRE(!walls.empty());
        // Note: UTF-8 chars are multi-byte
        REQUIRE(walls.length() > 6);
    }
}

TEST_CASE("Game constants", "[game]") {
    SECTION("Map dimensions") {
        constexpr int MAP_WIDTH = 80;
        constexpr int MAP_HEIGHT = 24;
        
        REQUIRE(MAP_WIDTH > 0);
        REQUIRE(MAP_HEIGHT > 0);
        REQUIRE(MAP_WIDTH * MAP_HEIGHT == 1920);
    }
    
    SECTION("Entity limits") {
        constexpr int MAX_INVENTORY = 10;
        constexpr int MAX_MONSTERS = 50;
        
        REQUIRE(MAX_INVENTORY > 0);
        REQUIRE(MAX_MONSTERS > MAX_INVENTORY);
    }
}
```

### Step 5: Build and Test Script

Create a helper script `build.sh` (or `build.bat` for Windows):

```bash
#!/bin/bash
# build.sh - Build helper script for Veyrm

set -e  # Exit on error

echo "========================================="
echo "Veyrm Build Script"
echo "========================================="

# Parse arguments
BUILD_TYPE=${1:-Debug}
CLEAN_BUILD=${2:-no}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Clean if requested
if [ "$CLEAN_BUILD" = "clean" ]; then
    echo -e "${YELLOW}Cleaning build directory...${NC}"
    rm -rf build
fi

# Create build directory
mkdir -p build
cd build

# Configure
echo -e "${YELLOW}Configuring CMake (${BUILD_TYPE})...${NC}"
cmake -DCMAKE_BUILD_TYPE=${BUILD_TYPE} ..

# Build
echo -e "${YELLOW}Building project...${NC}"
cmake --build . --parallel

# Run tests
echo -e "${YELLOW}Running tests...${NC}"
ctest --output-on-failure || echo -e "${RED}Some tests failed${NC}"

# Success message
echo -e "${GREEN}=========================================${NC}"
echo -e "${GREEN}Build complete!${NC}"
echo -e "${GREEN}=========================================${NC}"
echo ""
echo "Executable: ./build/bin/veyrm"
echo "Tests: ./build/bin/veyrm_tests"
echo ""
echo "Run options:"
echo "  ./build/bin/veyrm          # Run with UI"
echo "  ./build/bin/veyrm --test   # Run system checks"
echo "  ./build/bin/veyrm --no-ui  # Run without UI"
echo "  ./build/bin/veyrm_tests    # Run unit tests"
```

Make it executable:
```bash
chmod +x build.sh
```

## Validation Checklist

### Build Validation

- [ ] CMake configures without errors
- [ ] Dependencies download successfully
- [ ] Project builds without warnings
- [ ] All three libraries are linked correctly

### Functionality Tests

- [ ] `veyrm --version` shows all dependencies
- [ ] `veyrm --test` passes all checks
- [ ] `veyrm --no-ui` runs without launching UI
- [ ] `veyrm` launches FTXUI interface
- [ ] Menu navigation works (arrow keys)
- [ ] 'q' or ESC quits the application
- [ ] About dialog displays version info

### Unit Tests

- [ ] Test executable builds
- [ ] JSON tests pass
- [ ] Basic tests pass
- [ ] `ctest` runs all tests successfully

## Troubleshooting

### FetchContent Download Issues

If downloads fail:

1. **Check internet connection**
2. **Try shallow clone:**
   ```cmake
   GIT_SHALLOW TRUE
   GIT_PROGRESS TRUE
   ```
3. **Use specific commits instead of tags:**
   ```cmake
   GIT_TAG <commit-hash>
   ```

### FTXUI Display Issues

**Problem:** Characters don't display correctly
- **Solution:** Ensure terminal supports UTF-8
- **Windows:** Use Windows Terminal or ConEmu
- **Linux/Mac:** Set `export LANG=en_US.UTF-8`

**Problem:** Colors don't work
- **Solution:** Check terminal color support
- **Windows:** Add `FTXUI_MICROSOFT_TERMINAL_FALLBACK_COLORS` definition

### Compiler Warnings

**C++23 not supported:**
```cmake
set(CMAKE_CXX_STANDARD 20)  # Fallback to C++20
```

**Deprecated warnings:**
```cmake
# Suppress specific warnings if needed
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(-Wno-deprecated-declarations)
endif()
```

### Memory Sanitizer Issues (Debug mode)

If AddressSanitizer causes issues:
```cmake
# Disable sanitizer
# Remove: -fsanitize=address
```

## Git Commands

After implementing this phase:

```bash
# Create feature branch
git checkout -b feature/phase-0.2-dependencies

# Add files
git add .

# Commit
git commit -m "[Phase 0.2] Configure dependencies and FTXUI interface

- Integrated FTXUI v5.0.0 for terminal UI
- Added nlohmann/json v3.11.3 for data handling
- Configured Catch2 v3.5.1 for unit testing
- Created basic FTXUI menu interface
- Implemented JSON functionality tests
- Added build script for easier compilation
- Tests: All dependencies working, UI launches, tests pass
- Docs: Created detailed phase documentation"

# Tag
git tag v0.0.2-dependencies

# Merge to main
git checkout main
git merge feature/phase-0.2-dependencies

# Push with tags
git push origin main --tags
```

## Implementation Notes

### Issues Encountered and Resolved

1. **AddressSanitizer Conflict**: FTXUI v5.0.0 has known issues with AddressSanitizer causing container-overflow errors. Resolved by removing `-fsanitize=address` from CMakeLists.txt compiler options.

2. **Screen Initialization**: Initial implementation incorrectly created local ScreenInteractive object in menu function. Fixed by passing screen pointer from main runInterface() function.

3. **Terminal Mouse Tracking**: FTXUI leaves mouse tracking enabled after exit, causing terminal issues. Added cleanup code with escape sequences to disable all mouse modes on exit.

### Enhancements Beyond Original Spec

1. **Enhanced build.sh Script**:
   - Interactive menu system for common tasks
   - Command-line parameters for automation
   - Terminal reset functionality
   - Automatic terminal cleanup after game runs

2. **Terminal Reset Escape Sequences**:

   ```cpp
   std::cout << "\033[?1003l"; // Disable mouse tracking
   std::cout << "\033[?1006l"; // Disable SGR mouse mode
   std::cout << "\033[?1015l"; // Disable urxvt mouse mode
   std::cout << "\033[?1000l"; // Disable X11 mouse reporting
   std::cout << "\033[?25h";   // Show cursor
   ```

## Success Criteria

✅ Phase 0.2 is complete when:

1. ✅ All three dependencies are integrated via FetchContent
2. ✅ FTXUI menu interface launches and responds to input
3. ✅ JSON library can parse and serialize data
4. ✅ Catch2 tests run and pass (4/4 tests passing)
5. ✅ System checks (`--test`) show all green
6. ✅ No compiler warnings or errors
7. ✅ Code is committed and tagged as v0.0.2-dependencies

## Status: COMPLETED

All requirements met and validated. Additional fixes implemented for stability.

## Performance Notes

- First build will be slower (downloading dependencies)
- Subsequent builds use cached dependencies
- FetchContent caches in `build/_deps/`
- Clean build removes cache: `rm -rf build`

## Next Phase

Once this phase is complete and validated, proceed to:
**Phase 0.3: Basic FTXUI Window** - Set up the game's UI layout with proper panels
