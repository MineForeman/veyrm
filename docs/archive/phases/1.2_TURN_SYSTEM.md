# Phase 1.2: Turn System - Detailed Implementation Guide

## Overview

This phase establishes a proper turn-based system that distinguishes between player actions and world updates. We'll create a turn manager that coordinates when entities act, ensuring the game follows traditional roguelike turn-based mechanics.

## Prerequisites

- Phase 1.1 completed (Game State Structure with InputHandler)
- Basic player movement and turn counter working
- State management system in place

## Current State

From Phase 1.1, we have:
- Basic turn counter that increments on player actions
- Player movement handled through InputHandler
- No distinction between player and world turns
- No entity action scheduling

## Goals for Phase 1.2

1. Create a proper TurnManager class
2. Distinguish between player turns and world turns
3. Implement action points/speed system foundation
4. Add turn phases (player input → player action → world update)
5. Create message system for turn events

## Step-by-Step Implementation

### Step 1: Create TurnManager Class

Create `include/turn_manager.h`:

```cpp
#pragma once

#include <vector>
#include <functional>
#include <queue>
#include <memory>

enum class TurnPhase {
    WAITING_FOR_INPUT,
    PLAYER_ACTION,
    WORLD_UPDATE,
    TURN_COMPLETE
};

enum class ActionSpeed {
    INSTANT = 0,      // No time cost
    FAST = 50,        // Half a turn
    NORMAL = 100,     // Standard turn
    SLOW = 150,       // 1.5 turns
    VERY_SLOW = 200   // 2 turns
};

// Forward declarations
class GameManager;

// Represents a scheduled action
struct ScheduledAction {
    int executionTime;
    std::function<void()> action;
    
    bool operator>(const ScheduledAction& other) const {
        return executionTime > other.executionTime;
    }
};

class TurnManager {
public:
    TurnManager(GameManager* game_manager);
    
    // Turn flow control
    void startPlayerTurn();
    void executePlayerAction(ActionSpeed speed);
    void processWorldTurn();
    void endTurn();
    
    // Action scheduling
    void scheduleAction(int delay, std::function<void()> action);
    void processScheduledActions();
    
    // Turn information
    int getCurrentTurn() const { return current_turn; }
    int getWorldTime() const { return world_time; }
    TurnPhase getCurrentPhase() const { return current_phase; }
    bool isPlayerTurn() const { return current_phase == TurnPhase::WAITING_FOR_INPUT; }
    
    // Speed/time management
    int getActionCost(ActionSpeed speed) const;
    void advanceTime(int amount);
    
private:
    GameManager* game_manager;
    int current_turn;
    int world_time;  // In action points (100 = 1 standard turn)
    int player_next_action_time;
    TurnPhase current_phase;
    
    // Priority queue for scheduled actions
    std::priority_queue<ScheduledAction, 
                       std::vector<ScheduledAction>, 
                       std::greater<ScheduledAction>> action_queue;
};
```

### Step 2: Implement TurnManager

Create `src/turn_manager.cpp`:

```cpp
#include "turn_manager.h"
#include "game_state.h"
#include <iostream>

TurnManager::TurnManager(GameManager* gm) 
    : game_manager(gm),
      current_turn(0),
      world_time(0),
      player_next_action_time(0),
      current_phase(TurnPhase::WAITING_FOR_INPUT) {
}

void TurnManager::startPlayerTurn() {
    current_phase = TurnPhase::WAITING_FOR_INPUT;
    // Player can act when world_time >= player_next_action_time
}

void TurnManager::executePlayerAction(ActionSpeed speed) {
    if (current_phase != TurnPhase::WAITING_FOR_INPUT) {
        return;
    }
    
    current_phase = TurnPhase::PLAYER_ACTION;
    
    // Calculate time cost of action
    int cost = getActionCost(speed);
    player_next_action_time = world_time + cost;
    
    // Process the action (handled by game logic)
    current_turn++;
    
    // Move to world update phase
    processWorldTurn();
}

void TurnManager::processWorldTurn() {
    current_phase = TurnPhase::WORLD_UPDATE;
    
    // Advance time to next player action
    int time_to_advance = player_next_action_time - world_time;
    if (time_to_advance > 0) {
        advanceTime(time_to_advance);
    }
    
    // Process any scheduled actions that are due
    processScheduledActions();
    
    // TODO: Update monsters, effects, etc.
    
    endTurn();
}

void TurnManager::endTurn() {
    current_phase = TurnPhase::TURN_COMPLETE;
    
    // Check if player can act again
    if (world_time >= player_next_action_time) {
        startPlayerTurn();
    }
}

void TurnManager::scheduleAction(int delay, std::function<void()> action) {
    action_queue.push({world_time + delay, action});
}

void TurnManager::processScheduledActions() {
    while (!action_queue.empty() && 
           action_queue.top().executionTime <= world_time) {
        auto scheduled = action_queue.top();
        action_queue.pop();
        scheduled.action();
    }
}

int TurnManager::getActionCost(ActionSpeed speed) const {
    return static_cast<int>(speed);
}

void TurnManager::advanceTime(int amount) {
    world_time += amount;
}
```

### Step 3: Create Message System

Create `include/message_log.h`:

```cpp
#pragma once

#include <string>
#include <deque>
#include <ftxui/dom/elements.hpp>

class MessageLog {
public:
    MessageLog(size_t max_messages = 100);
    
    // Add messages
    void addMessage(const std::string& message);
    void addCombatMessage(const std::string& message);
    void addSystemMessage(const std::string& message);
    
    // Get messages for display
    std::vector<std::string> getRecentMessages(size_t count = 5) const;
    ftxui::Element render(size_t count = 5) const;
    
    // Clear
    void clear();
    
private:
    std::deque<std::string> messages;
    size_t max_size;
};
```

### Step 4: Implement Message System

Create `src/message_log.cpp`:

```cpp
#include "message_log.h"

using namespace ftxui;

MessageLog::MessageLog(size_t max_messages) 
    : max_size(max_messages) {
    addMessage("Welcome to Veyrm!");
}

void MessageLog::addMessage(const std::string& message) {
    messages.push_back(message);
    while (messages.size() > max_size) {
        messages.pop_front();
    }
}

void MessageLog::addCombatMessage(const std::string& message) {
    addMessage("[Combat] " + message);
}

void MessageLog::addSystemMessage(const std::string& message) {
    addMessage("[System] " + message);
}

std::vector<std::string> MessageLog::getRecentMessages(size_t count) const {
    std::vector<std::string> recent;
    size_t start = messages.size() > count ? messages.size() - count : 0;
    
    for (size_t i = start; i < messages.size(); ++i) {
        recent.push_back(messages[i]);
    }
    
    return recent;
}

Element MessageLog::render(size_t count) const {
    std::vector<Element> elements;
    auto recent = getRecentMessages(count);
    
    for (const auto& msg : recent) {
        elements.push_back(text(msg));
    }
    
    // Pad with empty lines if needed
    while (elements.size() < count) {
        elements.push_back(text(""));
    }
    
    return vbox(elements);
}

void MessageLog::clear() {
    messages.clear();
    addMessage("Message log cleared.");
}
```

### Step 5: Integrate with GameManager

Update `include/game_state.h`:

```cpp
// Add to GameManager class:
public:
    // Turn management
    TurnManager* getTurnManager() { return turn_manager.get(); }
    MessageLog* getMessageLog() { return message_log.get(); }
    
    // Process a player action with timing
    void processPlayerAction(ActionSpeed speed);
    
private:
    std::unique_ptr<TurnManager> turn_manager;
    std::unique_ptr<MessageLog> message_log;
```

Update `src/game_manager.cpp`:

```cpp
// Add includes
#include "turn_manager.h"
#include "message_log.h"

// Update constructor
GameManager::GameManager() 
    : current_state(GameState::MENU),
      previous_state(GameState::MENU),
      input_handler(std::make_unique<InputHandler>()),
      turn_manager(std::make_unique<TurnManager>(this)),
      message_log(std::make_unique<MessageLog>()) {
}

void GameManager::processPlayerAction(ActionSpeed speed) {
    turn_manager->executePlayerAction(speed);
}
```

### Step 6: Update Game Screen

Modify `src/game_screen.cpp` to use TurnManager:

```cpp
// In input handling section, update movement actions:
case InputAction::MOVE_UP:
    if (game_manager->player_y > 1) {
        game_manager->player_y--;
        game_manager->processPlayerAction(ActionSpeed::NORMAL);
        game_manager->getMessageLog()->addMessage("You move north.");
    }
    return true;

// Update CreateLogPanel to use MessageLog:
Component GameScreen::CreateLogPanel() {
    return Renderer([this] {
        return game_manager->getMessageLog()->render(5) | 
               border | 
               size(HEIGHT, EQUAL, 7);
    });
}

// Update CreateStatusPanel to show world time:
Component GameScreen::CreateStatusPanel() {
    return Renderer([this] {
        auto tm = game_manager->getTurnManager();
        return hbox({
            text("HP: " + std::to_string(game_manager->player_hp) + "/" + 
                 std::to_string(game_manager->player_max_hp)) | bold,
            separator(),
            text("Turn: " + std::to_string(tm->getCurrentTurn())),
            separator(),
            text("Time: " + std::to_string(tm->getWorldTime())),
            separator(),
            text("Depth: 1"),
        }) | border | size(HEIGHT, EQUAL, 3);
    });
}
```

## Testing Checklist

### Core Functionality

- [ ] Turn counter increments on player actions
- [ ] World time advances based on action speed
- [ ] Message log displays and updates
- [ ] Turn phases transition correctly
- [ ] Player can only act when it's their turn

### Action Speed Tests

- [ ] Movement costs normal speed (100 AP)
- [ ] Waiting costs normal speed
- [ ] Different actions can have different costs
- [ ] Time advances correctly

### Message System Tests

- [ ] Messages appear in log panel
- [ ] Recent messages displayed (max 5)
- [ ] Combat and system messages formatted differently
- [ ] Log doesn't overflow panel

### Integration Tests

- [ ] No crashes during gameplay
- [ ] Memory management correct
- [ ] State transitions still work
- [ ] Input handling integrated with turn system

## Common Issues and Solutions

### Issue: Actions Execute Multiple Times

**Solution:** Ensure input handler only processes once per key press and TurnManager validates phase before executing.

### Issue: Time Not Advancing

**Solution:** Check that `processWorldTurn()` is called after player actions and time advancement logic is correct.

### Issue: Messages Not Displaying

**Solution:** Verify MessageLog is properly initialized and render method is called in CreateLogPanel.

## Validation Commands

```bash
# Build and test
./build.sh clean build
./build/bin/veyrm

# Test sequence:
# 1. Start new game
# 2. Move around - verify turn counter increases
# 3. Check that time advances in status bar
# 4. Verify messages appear in log
# 5. Try different movement patterns
```

## Git Completion

```bash
# After implementation
git add .
git commit -m "[Phase 1.2] Implement Turn System

- Created TurnManager with player/world turn distinction
- Added action speed and time management
- Implemented message log system
- Integrated turn phases with game flow
- Tests: Turn counting, time advancement, message display working"

# Tag
git tag v0.1.2-turn-system

# Push
git push origin main --tags
```

## Success Criteria

✅ Phase 1.2 is complete when:

1. TurnManager properly coordinates player and world turns
2. Action speeds affect time advancement
3. Message log displays game events
4. Turn counter and world time shown in UI
5. Scheduled actions system functional
6. All tests pass without crashes

## Next Phase

Once complete, proceed to:
**Phase 1.3: Main Game Loop** - Connect input → update → render cycle with frame rate control