# Phase 2.1: Tile System

## Overview

Implement the foundational tile system that represents the game world as a 2D grid. This system defines the basic building blocks of maps, including tile types, properties, and the coordinate system used throughout the game.

## Current State Analysis

### What We Have

- ✅ Game loop with update/render cycle
- ✅ Basic player position tracking (x, y coordinates)
- ✅ Simple hardcoded test map in GameScreen
- ✅ Character-based rendering with FTXUI

### What's Missing

- ❌ Proper tile enumeration and properties
- ❌ Map class to manage tile grid
- ❌ Coordinate system utilities
- ❌ Tile-based collision detection
- ❌ Visibility and memory tracking per tile

## Technical Requirements

### 1. Tile Types

```cpp
enum class TileType {
    // Basic tiles
    FLOOR,          // '.' - Walkable floor
    WALL,           // '#' - Solid wall
    STAIRS_DOWN,    // '>' - Stairs going down
    STAIRS_UP,      // '<' - Stairs going up
    
    // Doors (future)
    DOOR_CLOSED,    // '+' - Closed door
    DOOR_OPEN,      // '/' - Open door
    
    // Special tiles (future)
    WATER,          // '~' - Water tile
    LAVA,           // '~' - Lava tile (different color)
    
    // Meta tiles
    VOID,           // ' ' - Out of bounds/ungenerated
    UNKNOWN         // '?' - Not yet revealed
};
```

### 2. Tile Properties

```cpp
struct TileProperties {
    char glyph;           // Display character
    Color foreground;     // Text color
    Color background;     // Background color
    bool walkable;        // Can entities move through
    bool transparent;     // Can see through (for FOV)
    bool destructible;    // Can be destroyed/modified
    std::string name;     // Display name ("Stone Wall")
};
```

### 3. Coordinate System

```cpp
struct Point {
    int x;
    int y;
    
    // Constructors
    Point() : x(0), y(0) {}
    Point(int x, int y) : x(x), y(y) {}
    
    // Operators
    bool operator==(const Point& other) const;
    bool operator!=(const Point& other) const;
    Point operator+(const Point& other) const;
    Point operator-(const Point& other) const;
    
    // Utilities
    int distance(const Point& other) const;  // Manhattan distance
    double euclidean(const Point& other) const;  // Euclidean distance
    std::vector<Point> neighbors() const;  // Get adjacent points
    bool inBounds(int width, int height) const;
};
```

### 4. Map Class

```cpp
class Map {
public:
    static constexpr int DEFAULT_WIDTH = 80;
    static constexpr int DEFAULT_HEIGHT = 24;
    
    Map(int width = DEFAULT_WIDTH, int height = DEFAULT_HEIGHT);
    ~Map();
    
    // Tile access
    TileType getTile(int x, int y) const;
    TileType getTile(const Point& pos) const;
    void setTile(int x, int y, TileType type);
    void setTile(const Point& pos, TileType type);
    
    // Properties
    bool isWalkable(int x, int y) const;
    bool isWalkable(const Point& pos) const;
    bool isTransparent(int x, int y) const;
    bool isTransparent(const Point& pos) const;
    bool inBounds(int x, int y) const;
    bool inBounds(const Point& pos) const;
    
    // Visibility (for future FOV)
    bool isVisible(int x, int y) const;
    void setVisible(int x, int y, bool visible);
    bool isExplored(int x, int y) const;
    void setExplored(int x, int y, bool explored);
    
    // Rendering
    char getGlyph(int x, int y) const;
    Color getForeground(int x, int y) const;
    Color getBackground(int x, int y) const;
    
    // Map generation helpers
    void fill(TileType type);
    void createRoom(int x, int y, int width, int height);
    void createCorridor(const Point& start, const Point& end);
    
    // Getters
    int getWidth() const { return width; }
    int getHeight() const { return height; }
    
private:
    int width;
    int height;
    std::vector<std::vector<TileType>> tiles;
    std::vector<std::vector<bool>> visible;
    std::vector<std::vector<bool>> explored;
    
    // Tile properties lookup
    static const std::map<TileType, TileProperties> tileProperties;
};
```

## Implementation Details

### 1. Tile Properties Definition

```cpp
// In Map.cpp
const std::map<TileType, TileProperties> Map::tileProperties = {
    {TileType::FLOOR,       {'.', Color::GrayLight, Color::Black, true,  true,  false, "Stone Floor"}},
    {TileType::WALL,        {'#', Color::Gray,      Color::Black, false, false, true,  "Stone Wall"}},
    {TileType::STAIRS_DOWN, {'>', Color::Yellow,    Color::Black, true,  true,  false, "Stairs Down"}},
    {TileType::STAIRS_UP,   {'<', Color::Yellow,    Color::Black, true,  true,  false, "Stairs Up"}},
    {TileType::DOOR_CLOSED, {'+', Color::Brown,     Color::Black, false, false, true,  "Closed Door"}},
    {TileType::DOOR_OPEN,   {'/', Color::Brown,     Color::Black, true,  true,  false, "Open Door"}},
    {TileType::WATER,       {'~', Color::Blue,      Color::Black, false, true,  false, "Water"}},
    {TileType::LAVA,        {'~', Color::Red,       Color::Black, false, true,  false, "Lava"}},
    {TileType::VOID,        {' ', Color::Black,     Color::Black, false, false, false, "Void"}},
    {TileType::UNKNOWN,     {'?', Color::GrayDark,  Color::Black, false, false, false, "Unknown"}},
};
```

### 2. Coordinate Utilities

```cpp
// Common direction vectors
namespace Direction {
    const Point NORTH(0, -1);
    const Point SOUTH(0, 1);
    const Point EAST(1, 0);
    const Point WEST(-1, 0);
    const Point NORTHEAST(1, -1);
    const Point NORTHWEST(-1, -1);
    const Point SOUTHEAST(1, 1);
    const Point SOUTHWEST(-1, 1);
    
    const std::vector<Point> CARDINAL = {NORTH, SOUTH, EAST, WEST};
    const std::vector<Point> DIAGONAL = {NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST};
    const std::vector<Point> ALL = {NORTH, SOUTH, EAST, WEST, 
                                    NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST};
}
```

### 3. Integration with GameScreen

Replace the hardcoded map in GameScreen with the Map class:

```cpp
// In GameScreen
Component GameScreen::CreateMapPanel() {
    return Renderer([this] {
        auto& map = game_manager->getMap();
        std::vector<Element> map_lines;
        
        for (int y = 0; y < map.getHeight(); y++) {
            std::string line;
            std::vector<Element> row_elements;
            
            for (int x = 0; x < map.getWidth(); x++) {
                // Check for player position
                if (x == game_manager->player_x && y == game_manager->player_y) {
                    row_elements.push_back(text("@") | color(Color::White));
                } else if (map.isVisible(x, y)) {
                    char glyph = map.getGlyph(x, y);
                    Color fg = map.getForeground(x, y);
                    row_elements.push_back(text(std::string(1, glyph)) | color(fg));
                } else if (map.isExplored(x, y)) {
                    char glyph = map.getGlyph(x, y);
                    row_elements.push_back(text(std::string(1, glyph)) | color(Color::GrayDark));
                } else {
                    row_elements.push_back(text(" "));
                }
            }
            map_lines.push_back(hbox(row_elements));
        }
        
        return vbox(map_lines) | border;
    });
}
```

## Implementation Checklist

### Core Components

- [ ] Create TileType enum
- [ ] Create TileProperties struct
- [ ] Create Point struct with operators
- [ ] Create Direction namespace
- [ ] Create Map class

### Map Implementation

- [ ] Implement tile storage (2D vector)
- [ ] Implement visibility tracking
- [ ] Implement exploration tracking
- [ ] Add bounds checking
- [ ] Add property lookups

### Integration

- [ ] Add Map to GameManager
- [ ] Update GameScreen to use Map
- [ ] Update player movement to check walkability
- [ ] Add collision detection
- [ ] Update rendering to show tiles

### Testing

- [ ] Test tile property lookups
- [ ] Test coordinate operations
- [ ] Test bounds checking
- [ ] Test map generation helpers
- [ ] Test visibility/exploration tracking

## File Structure

```
include/
  tile.h          # TileType enum and TileProperties
  point.h         # Point struct and Direction namespace
  map.h           # Map class
  
src/
  point.cpp       # Point implementation
  map.cpp         # Map implementation
  
tests/
  test_tile.cpp   # Tile system tests
  test_point.cpp  # Coordinate tests
  test_map.cpp    # Map tests
```

## Success Criteria

1. **Tile System Works**: Can create and query tiles
2. **Coordinates Work**: Point math and bounds checking functional
3. **Map Renders**: Tiles display correctly with proper colors
4. **Collision Works**: Player cannot walk through walls
5. **Memory Works**: Explored areas remain visible when out of sight

## Testing Strategy

### Unit Tests

```cpp
// Test tile properties
TEST_CASE("Tile properties are correct") {
    Map map(10, 10);
    map.setTile(5, 5, TileType::WALL);
    
    REQUIRE(map.getTile(5, 5) == TileType::WALL);
    REQUIRE(map.isWalkable(5, 5) == false);
    REQUIRE(map.isTransparent(5, 5) == false);
    REQUIRE(map.getGlyph(5, 5) == '#');
}

// Test point operations
TEST_CASE("Point operations work correctly") {
    Point p1(3, 4);
    Point p2(1, 2);
    Point p3 = p1 + p2;
    
    REQUIRE(p3.x == 4);
    REQUIRE(p3.y == 6);
    REQUIRE(p1.distance(p2) == 4);  // Manhattan distance
}

// Test bounds checking
TEST_CASE("Map bounds checking works") {
    Map map(10, 10);
    
    REQUIRE(map.inBounds(5, 5) == true);
    REQUIRE(map.inBounds(-1, 5) == false);
    REQUIRE(map.inBounds(5, 10) == false);
}
```

### Integration Tests

1. Create a simple test map
2. Place player on floor tile
3. Try to move into wall (should fail)
4. Try to move onto floor (should succeed)
5. Verify rendering shows correct glyphs

## Performance Considerations

### Memory Usage

- 80x24 map = 1,920 tiles
- Per tile: 1 byte (enum) + 2 bits (visible/explored) ≈ 2 bytes
- Total: ~4KB per map (very efficient)

### Access Patterns

- Tile lookups: O(1) constant time
- Rendering: O(width × height) per frame
- Use cache-friendly row-major ordering

## Future Enhancements

1. **Tile Variants**: Multiple wall styles, floor patterns
2. **Animated Tiles**: Water flow, lava bubbling
3. **Interactive Tiles**: Pressure plates, switches
4. **Tile Effects**: Damage from lava, slow in water
5. **Dynamic Tiles**: Destructible walls, growing vegetation
6. **Tile Metadata**: Custom properties per tile instance

## Dependencies

- FTXUI for Color enum
- No external dependencies for core tile system

## Next Steps

After Phase 2.1:

- Phase 2.2: Map Rendering (optimize and enhance display)
- Phase 2.3: Simple Test Map (create playable area)
- Phase 5.x: Map Generation (procedural dungeons)
