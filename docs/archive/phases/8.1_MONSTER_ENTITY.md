# Phase 8.1: Monster Entity

## Overview

Phase 8.1 establishes the foundation for the monster system by creating a Monster class that extends the existing Entity system. This phase focuses on the data structures and loading mechanisms needed to represent different monster types.

## Requirements

### Core Components

1. **Monster Class**
   - Extends the existing Entity base class
   - Adds monster-specific attributes and behaviors
   - Supports different monster types/species

2. **Combat Statistics**
   - Hit Points (HP) - current and maximum
   - Attack power - base damage dealt
   - Defense - damage reduction
   - Speed - turn frequency
   - Experience value - XP granted when defeated

3. **Data-Driven Design**
   - Load monster definitions from JSON files
   - Support for multiple monster types
   - Easy addition of new monsters without code changes

4. **Initial Monster Types**
   - Gutter Rat - weak, fast, common
   - Orc Rookling - moderate strength, basic enemy

## Implementation Tasks

### 1. Create Monster Class

```cpp
// include/monster.h
#pragma once
#include "entity.h"
#include <string>

class Monster : public Entity {
public:
    // Monster-specific stats
    int attack;
    int defense;
    int speed;
    int xp_value;
    
    // Monster metadata
    std::string species;
    std::string description;
    char threat_level;  // 'a' to 'z' indicating difficulty
    
    // Behavior flags
    bool aggressive = true;
    bool can_open_doors = false;
    bool can_see_invisible = false;
    
    // Constructor
    Monster(int x, int y, const std::string& species);
    
    // Override Entity methods
    EntityType getType() const override { return EntityType::MONSTER; }
    bool isBlocking() const override { return true; }
    
    // Monster-specific methods
    int calculateDamage() const;
    void takeDamage(int amount);
    bool isDead() const { return hp <= 0; }
};
```

### 2. Monster Definition Format

```json
// data/monsters.json
{
  "monsters": [
    {
      "id": "gutter_rat",
      "name": "Gutter Rat",
      "description": "A diseased rat from the sewers",
      "glyph": "r",
      "color": "brown",
      "hp": 3,
      "attack": 2,
      "defense": 0,
      "speed": 120,
      "xp_value": 2,
      "threat_level": "a",
      "flags": {
        "aggressive": true,
        "can_open_doors": false
      }
    },
    {
      "id": "orc_rookling",
      "name": "Orc Rookling",
      "description": "A young orc warrior in training",
      "glyph": "o",
      "color": "green",
      "hp": 8,
      "attack": 4,
      "defense": 1,
      "speed": 100,
      "xp_value": 10,
      "threat_level": "c",
      "flags": {
        "aggressive": true,
        "can_open_doors": true
      }
    }
  ]
}
```

### 3. Monster Factory/Loader

```cpp
// include/monster_factory.h
#pragma once
#include <memory>
#include <map>
#include <nlohmann/json.hpp>

class Monster;

class MonsterFactory {
public:
    static MonsterFactory& getInstance();
    
    // Load monster definitions from JSON
    bool loadFromFile(const std::string& filename);
    bool loadFromJson(const nlohmann::json& data);
    
    // Create monster instances
    std::unique_ptr<Monster> createMonster(
        const std::string& species, 
        int x, int y
    );
    
    // Query available monsters
    std::vector<std::string> getAvailableSpecies() const;
    bool hasSpecies(const std::string& species) const;
    
private:
    struct MonsterTemplate {
        std::string name;
        std::string description;
        std::string glyph;
        Color color;
        int hp;
        int attack;
        int defense;
        int speed;
        int xp_value;
        char threat_level;
        std::map<std::string, bool> flags;
    };
    
    std::map<std::string, MonsterTemplate> templates;
    
    MonsterFactory() = default;
};
```

### 4. Integration with Entity System

```cpp
// Extend EntityType enum
enum class EntityType {
    NONE,
    PLAYER,
    MONSTER,  // New type
    ITEM,
    FEATURE
};

// Update EntityManager to handle monsters
class EntityManager {
    std::vector<std::unique_ptr<Monster>> monsters;
    
public:
    // Monster management
    Monster* createMonster(const std::string& species, int x, int y);
    void removeMonster(Monster* monster);
    std::vector<Monster*> getMonstersAt(int x, int y);
    std::vector<Monster*> getAllMonsters();
    std::vector<Monster*> getVisibleMonsters();
};
```

## Testing Requirements

### Unit Tests

1. **Monster Class Tests**
   - Construction with different stats
   - Damage calculation
   - Death detection
   - Stat modifications

2. **Monster Factory Tests**
   - JSON loading and parsing
   - Template storage
   - Monster creation from templates
   - Error handling for missing species

3. **Integration Tests**
   - Monsters in EntityManager
   - Collision detection with monsters
   - Visibility system integration

### Test Data

Create simplified test monster data:

```json
{
  "monsters": [
    {
      "id": "test_monster",
      "name": "Test Monster",
      "glyph": "T",
      "color": "white",
      "hp": 10,
      "attack": 5,
      "defense": 2,
      "speed": 100,
      "xp_value": 1
    }
  ]
}
```

## Files to Create/Modify

### New Files

1. `include/monster.h` - Monster class definition
2. `src/monster.cpp` - Monster implementation
3. `include/monster_factory.h` - Factory for creating monsters
4. `src/monster_factory.cpp` - Factory implementation
5. `data/monsters.json` - Monster definitions
6. `tests/test_monster.cpp` - Monster unit tests
7. `tests/test_monster_factory.cpp` - Factory tests

### Modified Files

1. `include/entity.h` - Add MONSTER to EntityType enum
2. `include/entity_manager.h` - Add monster management methods
3. `src/entity_manager.cpp` - Implement monster management
4. `CMakeLists.txt` - Add new source files
5. `tests/CMakeLists.txt` - Add new test files

## Success Criteria

1. **Data Loading**: Monsters load correctly from JSON files
2. **Creation**: Can create monster instances with proper stats
3. **Integration**: Monsters work with existing entity system
4. **Extensibility**: Easy to add new monster types via JSON
5. **Testing**: All tests pass with good coverage

## Dependencies

- Entity system (✅ Complete)
- JSON loading with nlohmann/json (✅ Available)
- Color system (✅ Complete)
- EntityManager (✅ Complete)

## Implementation Order

1. Create Monster class extending Entity
2. Implement MonsterFactory for data loading
3. Create initial monsters.json with two monsters
4. Integrate with EntityManager
5. Write comprehensive tests
6. Documentation

## Future Enhancements (Phase 8.2+)

- Monster spawning during map generation
- AI behavior system
- Special abilities and attacks
- Monster groups and formations
- Unique/boss monsters
- Monster inventory (loot drops)
- Status effects on monsters

## Notes

- Keep monster stats simple initially
- Focus on data-driven design for easy content addition
- Ensure monsters integrate cleanly with existing systems
- Consider save/load requirements early
- Plan for future AI extensions
