# Phase 5.2: Corridor Generation

## Overview

Phase 5.2 implements corridor generation algorithms to connect rooms in procedurally generated dungeons. This phase focuses on creating natural-looking pathways between rooms while maintaining proper wall structure and ensuring connectivity.

## Current State

### What Already Exists

1. **Basic L-shaped Corridors** (`MapGenerator::carveCorridorL()`)
   - Carves horizontal then vertical paths
   - Adds walls around corridors
   - Handles corner wall placement
   - Used in fixed test dungeons

2. **Room Connection in Procedural Generation**
   - Simple sequential connection (room i to room i+1)
   - Uses room centers as connection points
   - Basic but functional connectivity

## Requirements

### Core Functionality

1. **Improved Corridor Algorithms**
   - [ ] Implement straight corridor option
   - [ ] Add configurable corridor width (1-3 tiles)
   - [ ] Support diagonal corridors (optional)
   - [ ] Add corridor style variations (straight, L-shaped, S-shaped)

2. **Smart Room Connection**
   - [ ] Implement minimum spanning tree for optimal connections
   - [ ] Add nearest neighbor connection option
   - [ ] Support multiple connection strategies
   - [ ] Ensure all rooms are reachable

3. **Door Placement System**
   - [ ] Detect corridor-room intersections
   - [ ] Place doors at room entrances
   - [ ] Support different door types (open, closed, locked)
   - [ ] Maintain door state in map

4. **Corridor Beautification**
   - [ ] Avoid unnecessary zigzags
   - [ ] Merge overlapping corridors
   - [ ] Clean up redundant walls
   - [ ] Add corridor rooms/intersections

## Implementation Tasks

### 1. Corridor Types

```cpp
enum class CorridorStyle {
    STRAIGHT,      // Direct path
    L_SHAPED,      // Current implementation
    S_SHAPED,      // Two bends
    ORGANIC        // Natural winding path
};

struct CorridorOptions {
    int width = 1;
    CorridorStyle style = CorridorStyle::L_SHAPED;
    bool allowDiagonal = false;
    bool placeDoors = true;
};
```

### 2. Connection Strategy

```cpp
enum class ConnectionStrategy {
    SEQUENTIAL,    // Current: connect rooms in order
    NEAREST,       // Connect to nearest unconnected room
    MST,           // Minimum spanning tree
    DELAUNAY,      // Delaunay triangulation based
    RANDOM         // Random connections ensuring connectivity
};
```

### 3. Door System

```cpp
enum class DoorState {
    NONE,          // No door
    OPEN,          // Open doorway
    CLOSED,        // Closed door
    LOCKED,        // Locked door
    SECRET         // Hidden door
};

// Add to TileType enum:
// DOOR_OPEN, DOOR_CLOSED, DOOR_LOCKED
```

### 4. Pathfinding for Corridors

- Use A* or Dijkstra for optimal paths
- Avoid carving through existing rooms
- Minimize total corridor length
- Handle obstacles and void spaces

## Algorithm Details

### Minimum Spanning Tree Connection

1. Calculate distances between all room pairs
2. Build MST using Kruskal's or Prim's algorithm
3. Connect rooms along MST edges
4. Optionally add extra connections for loops

### Smart L-Shaped Corridors

1. Determine midpoint for bend
2. Check for obstacles at bend point
3. Adjust bend location if needed
4. Ensure minimum corridor length

### Door Placement Algorithm

1. Find corridor-room intersection points
2. Check if location is suitable for door
3. Place door tile at intersection
4. Update surrounding walls if needed

## Testing Requirements

### Unit Tests

- [ ] Test each corridor style generation
- [ ] Verify room connectivity (all rooms reachable)
- [ ] Test door placement at intersections
- [ ] Validate corridor width consistency
- [ ] Check wall integrity around corridors

### Integration Tests

- [ ] Generate multiple dungeons with different strategies
- [ ] Verify no isolated rooms
- [ ] Test pathfinding through corridors
- [ ] Ensure doors are accessible

### Visual Tests

- [ ] Render dungeons with different corridor styles
- [ ] Verify corridors look natural
- [ ] Check door placement visually
- [ ] Ensure no graphical artifacts

## Files to Modify

1. **include/map_generator.h**
   - Add corridor generation methods
   - Add connection strategy enum
   - Add corridor options struct

2. **src/map_generator.cpp**
   - Implement new corridor algorithms
   - Add MST connection logic
   - Implement door placement

3. **include/map.h**
   - Add door tile types
   - Add door state tracking

4. **src/map.cpp**
   - Handle door tile properties
   - Add door interaction logic

5. **tests/test_corridor_generation.cpp** (new)
   - Unit tests for corridor algorithms
   - Connection strategy tests
   - Door placement tests

## Dependencies

- Phase 5.1 Room Generation (✅ Complete)
- Basic map structure (✅ Complete)
- Tile system (✅ Complete)

## Success Criteria

1. **Connectivity**: All rooms connected with no isolated areas
2. **Variety**: Multiple corridor styles available
3. **Quality**: Corridors look natural and purposeful
4. **Doors**: Properly placed at room entrances
5. **Performance**: Generation remains fast (<100ms for standard map)
6. **Testing**: All tests pass with >90% code coverage

## Future Enhancements

1. **Advanced Features**
   - Secret passages
   - One-way corridors
   - Trapped corridors
   - Corridor decorations

2. **Optimization**
   - Corridor caching
   - Parallel generation
   - Progressive generation

3. **Customization**
   - Theme-based corridor styles
   - Biome-specific corridors
   - Level-dependent complexity

## Notes

- Current L-shaped corridor implementation works well but needs refinement
- Door system will require extending TileType enum
- MST implementation can use standard graph algorithms
- Consider corridor width impact on gameplay and monster movement
- Ensure corridors don't make dungeons too open or too cramped
