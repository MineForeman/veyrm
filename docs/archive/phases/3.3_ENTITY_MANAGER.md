# Phase 3.3: Entity Manager

**Status:** ✅ Completed as part of Phase 3.1  
**Git Tag:** `v0.3.1-entity-base`

## Overview

Implement a centralized EntityManager class to handle the lifecycle of all game entities (players, monsters, items). This system provides efficient entity storage, retrieval, and spatial queries while maintaining clean separation between entity logic and game state.

## Prerequisites

- Phase 3.1 (Entity Base) must be complete
- Phase 3.2 (Player on Map) must be complete
- Entity base class and Player implementation functional

## Objectives

Create a robust entity management system that:
1. Manages entity lifecycle (creation, tracking, removal)
2. Provides efficient spatial queries (entities at position)
3. Supports different entity types (Player, Monster, Item)
4. Maintains entity relationships and state
5. Integrates cleanly with the existing game systems

## Implementation Tasks

### 3.3.1 Core EntityManager Class

**File:** `include/entity_manager.h`, `src/entity_manager.cpp`

```cpp
class EntityManager {
public:
    // Entity creation
    std::shared_ptr<Player> createPlayer(int x, int y);
    std::shared_ptr<Entity> createEntity(EntityType type, int x, int y);
    
    // Entity removal
    void removeEntity(std::shared_ptr<Entity> entity);
    void removeEntitiesAt(int x, int y);
    
    // Queries
    std::vector<std::shared_ptr<Entity>> getEntitiesAt(int x, int y);
    std::shared_ptr<Player> getPlayer();
    std::vector<std::shared_ptr<Entity>> getAllEntities();
    
    // Utility
    void clear();
    size_t getEntityCount() const;
    
private:
    std::vector<std::shared_ptr<Entity>> entities;
    std::shared_ptr<Player> player;
};
```

**Key Features:**
- Smart pointer management for automatic cleanup
- Efficient position-based queries
- Type-safe entity creation
- Player singleton tracking

### 3.3.2 Entity Type System

**File:** `include/entity_types.h`

```cpp
enum class EntityType {
    PLAYER,
    MONSTER,
    ITEM
};

// Factory function for entity creation
std::shared_ptr<Entity> createEntityOfType(EntityType type, int x, int y);
```

**Implementation Details:**
- Extensible enum for future entity types
- Factory pattern for clean entity instantiation
- Type-safe entity creation with proper inheritance

### 3.3.3 Integration with GameManager

**File:** `src/game_manager.cpp`

**Changes Required:**
```cpp
class GameManager {
private:
    std::unique_ptr<EntityManager> entity_manager;
    
public:
    // Remove direct player management
    // Player now accessed via entity_manager->getPlayer()
    
    void initializeGame() {
        entity_manager = std::make_unique<EntityManager>();
        auto player = entity_manager->createPlayer(spawn_x, spawn_y);
    }
    
    void handlePlayerMovement(int dx, int dy) {
        auto player = entity_manager->getPlayer();
        if (player && player->tryMove(map, entity_manager.get(), dx, dy)) {
            // Movement successful
        }
    }
};
```

### 3.3.4 Spatial Query Optimization

**Performance Considerations:**
- Simple vector storage for MVP (< 1000 entities expected)
- Future optimization: spatial hash grid for O(1) position queries
- Entity removal using erase-remove idiom

```cpp
// Efficient entity removal
void EntityManager::removeEntity(std::shared_ptr<Entity> entity) {
    entities.erase(
        std::remove(entities.begin(), entities.end(), entity),
        entities.end()
    );
}
```

## Testing Requirements

### 3.3.1 Unit Tests

**File:** `tests/test_entity_manager.cpp`

**Test Cases:**
1. **EntityManager: Player creation** - Verify player entity creation and tracking
2. **EntityManager: Monster creation** - Test monster entity instantiation
3. **EntityManager: Item creation** - Test item entity creation
4. **EntityManager: Entity removal** - Verify proper cleanup and memory management
5. **EntityManager: Position queries** - Test spatial query functionality
6. **EntityManager: Entity counting** - Verify entity tracking accuracy

**Critical Tests:**
```cpp
TEST_CASE("EntityManager: Player creation", "[entity_manager]") {
    EntityManager manager;
    auto player = manager.createPlayer(10, 15);
    
    REQUIRE(player != nullptr);
    REQUIRE(player->x == 10);
    REQUIRE(player->y == 15);
    REQUIRE(manager.getPlayer() == player);
}

TEST_CASE("EntityManager: Position queries", "[entity_manager]") {
    EntityManager manager;
    auto entity = manager.createEntity(EntityType::MONSTER, 5, 5);
    
    auto entities_at_pos = manager.getEntitiesAt(5, 5);
    REQUIRE(entities_at_pos.size() == 1);
    REQUIRE(entities_at_pos[0] == entity);
}
```

### 3.3.2 Integration Tests

**Test Scenarios:**
- Entity creation and immediate queries
- Multiple entities at same position
- Entity removal and query consistency
- Player movement with entity collision detection
- Memory management (no leaks with smart pointers)

## Documentation Requirements

### 3.3.1 Code Documentation

- Full Doxygen comments for all public methods
- Usage examples for common patterns
- Performance characteristics documentation

### 3.3.2 Architecture Documentation

**Update:** `DOC/MVP/03_architecture.md`

Add EntityManager to the system architecture:
```
EntityManager
├── Entity Lifecycle Management
├── Spatial Queries (position-based)
├── Type-safe Entity Creation
└── Integration with Game Systems
```

## Integration Points

### 3.3.1 GameManager Integration

- Replace direct player management with EntityManager queries
- Update input handling to use entity_manager->getPlayer()
- Modify game state serialization to iterate through entities

### 3.3.2 Renderer Integration

- Renderer queries EntityManager for entities to display
- Layered rendering: map tiles, then entities by position
- Player rendering priority over other entities

### 3.3.3 Future System Preparation

- Monster AI system will query for nearby entities
- Combat system will use position-based entity queries
- Item pickup system will search for items at player position

## Performance Considerations

### 3.3.1 Current Implementation (MVP)

- Simple vector storage: O(n) queries acceptable for small entity counts
- Smart pointers: slight overhead but necessary for safe memory management
- Position queries: linear search through all entities

### 3.3.2 Future Optimizations (Post-MVP)

- Spatial hash grid: O(1) position queries for large entity counts
- Entity pooling: reduce allocation overhead
- Dirty flagging: only update spatial structures when entities move

## Error Handling

### 3.3.1 Robust Error Cases

```cpp
// Safe entity queries
auto entities = manager.getEntitiesAt(x, y);
if (entities.empty()) {
    // Handle no entities at position
}

// Player existence checks
auto player = manager.getPlayer();
if (!player) {
    // Handle missing player (error state)
}
```

### 3.3.2 Memory Safety

- Smart pointers prevent memory leaks
- Weak references where appropriate to avoid cycles
- Clear ownership semantics between EntityManager and Game systems

## Acceptance Criteria

### Functional Requirements

- [x] ✅ Create entities of different types (Player, Monster, Item)
- [x] ✅ Remove entities safely without memory leaks
- [x] ✅ Query entities by position efficiently
- [x] ✅ Track player entity separately for quick access
- [x] ✅ Integrate with existing game systems without breaking changes

### Quality Requirements

- [x] ✅ All unit tests pass (6 test cases minimum)
- [x] ✅ No memory leaks (verified with sanitizers)
- [x] ✅ Clean integration with GameManager
- [x] ✅ Performance acceptable for MVP scale (< 1000 entities)
- [x] ✅ Code follows project conventions and style

### Documentation Requirements

- [x] ✅ Full API documentation
- [x] ✅ Integration examples
- [x] ✅ Architecture documentation updated
- [x] ✅ Test coverage documented

## Git Workflow

```bash
# Create feature branch
git checkout -b feature/phase-3.3-entity-manager

# Implement EntityManager class
git add include/entity_manager.h src/entity_manager.cpp
git commit -m "[Phase 3.3] Implement EntityManager class

- Add entity lifecycle management
- Implement position-based queries
- Add type-safe entity creation"

# Add comprehensive tests
git add tests/test_entity_manager.cpp
git commit -m "[Phase 3.3] Add EntityManager tests

- Test entity creation and removal
- Test spatial queries
- Verify memory management"

# Integrate with GameManager
git add src/game_manager.cpp include/game_manager.h
git commit -m "[Phase 3.3] Integrate EntityManager with GameManager

- Replace direct player management
- Update input handling
- Maintain clean separation of concerns"

# Final testing and documentation
git add DOC/MVP/03_architecture.md
git commit -m "[Phase 3.3] Complete EntityManager documentation

- Update architecture documentation
- Add usage examples
- Document integration points"

# Merge to main
git checkout main
git merge feature/phase-3.3-entity-manager
git tag v0.3.3-entity-manager
git push origin main --tags
```

## Notes

**Current Status:** This phase was implemented as part of Phase 3.1 for efficiency and to avoid over-engineering. The EntityManager class exists in the current codebase with full functionality and comprehensive test coverage.

**Design Decisions:**
- Smart pointer management chosen over raw pointers for safety
- Simple vector storage preferred over complex spatial structures for MVP
- Centralized entity creation maintains consistency
- Player singleton pattern provides quick access while maintaining the entity hierarchy

**Lessons Learned:**
- Combining related phases (3.1, 3.2, 3.3) into a single implementation was more efficient
- Comprehensive testing during implementation caught edge cases early
- Clean separation between EntityManager and game logic improved testability

---

*Implementation completed in Phase 3.1 - Entity Base*  
*All acceptance criteria met with comprehensive test coverage*