# Phase 8.3: Basic AI Requirements

## Overview

Implement basic monster AI with movement, pathfinding, and behavioral states. Monsters should exhibit intelligent movement patterns while respecting room boundaries and player interactions.

## Core Requirements

### 1. Movement System

- **8-Way Movement**: Monsters must be able to move in all 8 directions (N, NE, E, SE, S, SW, W, NW)
- **Smooth Navigation**: Should handle diagonal movement naturally
- **Collision Detection**: Cannot move through walls, closed doors, or other blocking entities
- **Speed System**: Movement based on monster speed stat (turns between moves)

### 2. Room-Bound Behavior

- **Initial Room Assignment**: When a monster spawns in a room, it becomes "bound" to that room
- **Wandering Restriction**: Room-bound monsters should NOT wander outside their assigned room
- **Chase Exception**: Monsters CAN chase the player outside their room when aggressive
- **Return Behavior**: When losing sight of player, monster should return to their assigned room
- **Corridor Monsters**: Monsters spawned in corridors have no room restrictions

### 3. AI States

Monsters should have distinct behavioral states:

#### IDLE State

- Default state when no threat detected
- Random movement within allowed area (room for room-bound, anywhere for corridor monsters)
- Low frequency movements (not every turn)
- May stand still for several turns

#### ALERT State

- Triggered when player enters detection range
- Increased movement frequency
- Faces toward player's last known position
- May investigate last known player location

#### HOSTILE State

- Activated when player is visible and in aggression range
- Direct pursuit using pathfinding
- Will chase player outside of room boundaries
- Attempts to move toward player each turn

#### RETURNING State

- Activated when room-bound monster loses player outside their room
- Pathfinds back to assigned room
- Reverts to IDLE once inside room

### 4. Pathfinding

- **Algorithm**: A* or Dijkstra's algorithm for optimal paths
- **8-Direction Support**: Must handle diagonal movement costs
- **Obstacle Avoidance**: Navigate around other monsters and obstacles
- **Door Interaction**: Some monsters can open doors (based on can_open_doors flag)
- **Line of Sight**: Use FOV calculation to determine if monster can see player

### 5. Detection System

- **Vision Range**: Based on monster's vision_range stat
- **FOV Calculation**: Reuse player's FOV system for monster sight
- **Sound/Noise**: Optional - player actions could alert nearby monsters
- **Memory**: Monsters remember player's last seen position for a few turns

## Implementation Components

### Monster AI Component

```cpp
class MonsterAI {
    enum AIState {
        IDLE,
        ALERT, 
        HOSTILE,
        RETURNING
    };
    
    AIState current_state;
    Point home_room_center;  // For room-bound monsters
    Room* assigned_room;     // nullptr for corridor monsters
    Point last_player_pos;   // Last known player position
    int turns_since_player_seen;
    
    void updateState(const Player& player, const Map& map);
    Point chooseNextMove(const Map& map);
    bool canSeePlayer(const Player& player, const Map& map);
};
```

### Movement Validation

```cpp
struct Movement {
    // 8-direction movement vectors
    static const Point directions[8] = {
        {0, -1},   // N
        {1, -1},   // NE
        {1, 0},    // E
        {1, 1},    // SE
        {0, 1},    // S
        {-1, 1},   // SW
        {-1, 0},   // W
        {-1, -1}   // NW
    };
    
    bool isValidMove(Point from, Point to, const Map& map);
    float getMoveCost(Point from, Point to);  // Diagonal = 1.41, Cardinal = 1.0
};
```

### Pathfinding System

```cpp
class Pathfinder {
    std::vector<Point> findPath(Point start, Point goal, const Map& map, bool allow_diagonals = true);
    bool hasLineOfSight(Point from, Point to, const Map& map);
    float heuristic(Point a, Point b);  // Euclidean distance for 8-way movement
};
```

## Configuration (config.yml)

```yaml
ai:
  # Global AI settings
  pathfinding_max_steps: 100     # Maximum path length to calculate
  default_vision_range: 8        # Default monster vision range
  memory_turns: 5                # Turns to remember player position
  
  # State transition settings  
  alert_range: 10                # Distance to enter alert state
  hostile_range: 8               # Distance to become hostile
  return_threshold: 15           # Distance from room before returning
  
  # Movement behavior
  idle_move_chance: 0.25         # Chance to move when idle
  diagonal_move_cost: 1.41       # Cost multiplier for diagonal moves
  crowd_penalty: 2.0             # Path cost increase for occupied tiles
```

## Monster Data Updates

Add to `monsters.json`:

```json
{
  "species": "kobold",
  "vision_range": 8,
  "aggression_range": 6,
  "room_bound": true,
  "can_open_doors": true,
  "wander_chance": 0.3,
  "chase_persistence": 10  // Turns to chase before giving up
}
```

## Testing Requirements

### Unit Tests

1. **Movement Validation**: Test all 8 directions
2. **Room Boundary**: Verify monsters stay in rooms when not chasing
3. **State Transitions**: Test all state changes
4. **Pathfinding**: Verify optimal paths with obstacles
5. **Chase Behavior**: Confirm monsters can leave room when chasing

### Integration Tests

1. **Multi-Monster**: Multiple monsters navigating without collision
2. **Door Interaction**: Monsters opening doors appropriately
3. **Return Behavior**: Room-bound monsters returning after chase
4. **Performance**: Pathfinding with many monsters active

### Gameplay Tests

1. **Stealth**: Player can avoid detection
2. **Combat Approach**: Monsters close distance intelligently
3. **Room Defense**: Room monsters defend their territory
4. **Corridor Ambush**: Corridor monsters behave differently

## Success Criteria

- [ ] Monsters move in all 8 directions smoothly
- [ ] Room-bound monsters stay in their rooms when not chasing
- [ ] Monsters chase players intelligently using pathfinding
- [ ] Different monster species exhibit different behaviors
- [ ] AI performs well with 30+ monsters active
- [ ] Players can use tactics (stealth, luring, etc.)

## Technical Considerations

### Performance

- Cache pathfinding results when possible
- Use hierarchical pathfinding for long distances
- Limit FOV calculations to active monsters
- Consider "sleeping" distant monsters

### Edge Cases

- Monster spawned in doorway (which room?)
- Multiple monsters trying to occupy same space
- Player teleportation/stairs (clear last known position)
- Monsters in rooms with multiple sections
- Very large rooms (set maximum wander distance)

## Future Enhancements (Post-8.3)

- Group AI for pack monsters
- Fleeing behavior for weak/injured monsters
- Sound propagation system
- Monster communication (alerting others)
- Patrol routes for guards
- Ambush behaviors
- Territorial disputes between monster types

## Dependencies

- Phase 8.1: Monster Entity (COMPLETE)
- Phase 8.2: Monster Spawning (COMPLETE)
- FOV System (COMPLETE)
- Turn System (COMPLETE)

## Notes

- Start with simple state machine, refine based on playtesting
- Room-bound behavior creates tactical gameplay (luring monsters out)
- 8-way movement makes combat more fluid and positioning important
- Consider making some monsters "guards" that never leave their room
