# Phase 5.1: Room Generation

**Status:** ðŸ”„ Partially Complete (basic implementation exists)  
**Prerequisites:** Phase 3 (Entity System) complete  
**Git Tag:** `v0.5.1-room-generation` (when complete)

## Overview

Implement a robust room generation system for procedural dungeon creation. This phase focuses on creating rectangular rooms with randomized placement, overlap detection, and proper wall boundaries. The system should generate varied, playable layouts while ensuring all rooms are accessible.

## Current State

Basic room generation exists in `MapGenerator` with:

- Fixed room layouts for test maps
- Simple `carveRoom()` function that creates rectangular rooms
- Manual room placement in predetermined positions

## Objectives

1. Create a flexible Room class for room definitions
2. Implement random room placement algorithm
3. Add overlap detection to prevent room collisions
4. Generate varied room sizes within constraints
5. Ensure proper wall generation around rooms

## Implementation Tasks

### 5.1.1 Room Class Definition

**File:** `include/room.h`

```cpp
#pragma once
#include "point.h"
#include <vector>

class Room {
public:
    int x, y;          // Top-left corner
    int width, height; // Dimensions
    
    Room(int x, int y, int w, int h);
    
    // Get room center for corridor connections
    Point center() const;
    
    // Check if this room overlaps with another
    bool overlaps(const Room& other, int padding = 1) const;
    
    // Check if a point is inside this room
    bool contains(int px, int py) const;
    
    // Get room boundaries
    int left() const { return x; }
    int right() const { return x + width - 1; }
    int top() const { return y; }
    int bottom() const { return y + height - 1; }
    
    // Get room area
    int area() const { return width * height; }
    
    // Get perimeter points (for door placement)
    std::vector<Point> getPerimeter() const;
    
    // Room types for future expansion
    enum class RoomType {
        NORMAL,
        ENTRANCE,    // Starting room
        TREASURE,    // Loot room
        BOSS,        // Boss encounter
        CORRIDOR,    // Hallway connection
        SPECIAL      // Puzzle/special event
    };
    
    RoomType type = RoomType::NORMAL;
};
```

### 5.1.2 Room Generation Algorithm

**File:** `src/map_generator.cpp` (enhancement)

```cpp
class MapGenerator {
private:
    // Room generation parameters
    static constexpr int MIN_ROOM_SIZE = 4;
    static constexpr int MAX_ROOM_SIZE = 12;
    static constexpr int MIN_ROOMS = 8;
    static constexpr int MAX_ROOMS = 15;
    static constexpr int MAX_PLACEMENT_ATTEMPTS = 1000;
    
public:
    static std::vector<Room> generateRooms(Map& map, std::mt19937& rng) {
        std::vector<Room> rooms;
        std::uniform_int_distribution<int> room_width(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
        std::uniform_int_distribution<int> room_height(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
        std::uniform_int_distribution<int> x_pos(1, map.getWidth() - MAX_ROOM_SIZE - 1);
        std::uniform_int_distribution<int> y_pos(1, map.getHeight() - MAX_ROOM_SIZE - 1);
        
        int target_rooms = std::uniform_int_distribution<int>(MIN_ROOMS, MAX_ROOMS)(rng);
        int attempts = 0;
        
        while (rooms.size() < target_rooms && attempts < MAX_PLACEMENT_ATTEMPTS) {
            // Generate random room
            int w = room_width(rng);
            int h = room_height(rng);
            int x = x_pos(rng);
            int y = y_pos(rng);
            
            // Ensure room fits in map bounds
            if (x + w >= map.getWidth() - 1 || y + h >= map.getHeight() - 1) {
                attempts++;
                continue;
            }
            
            Room new_room(x, y, w, h);
            
            // Check for overlaps with existing rooms
            bool overlaps = false;
            for (const auto& room : rooms) {
                if (new_room.overlaps(room, 2)) { // 2 tile padding
                    overlaps = true;
                    break;
                }
            }
            
            if (!overlaps) {
                rooms.push_back(new_room);
                carveRoom(map, new_room);
            }
            
            attempts++;
        }
        
        return rooms;
    }
    
    static void carveRoom(Map& map, const Room& room) {
        // Carve out the room
        for (int y = room.y; y < room.y + room.height; y++) {
            for (int x = room.x; x < room.x + room.width; x++) {
                if (x == room.x || x == room.right() || 
                    y == room.y || y == room.bottom()) {
                    // Room walls
                    map.setTile(x, y, TileType::WALL);
                } else {
                    // Room floor
                    map.setTile(x, y, TileType::FLOOR);
                }
            }
        }
    }
};
```

### 5.1.3 Room Variety and Special Rooms

**Room Generation Patterns:**

```cpp
enum class RoomShape {
    RECTANGLE,    // Standard rectangular room
    SQUARE,       // Force square dimensions
    CROSS,        // Cross-shaped room
    CIRCLE,       // Circular room (approximated)
    IRREGULAR     // L-shaped or other irregular shapes
};

static Room generateShapedRoom(RoomShape shape, int x, int y, 
                               int base_size, std::mt19937& rng) {
    switch (shape) {
        case RoomShape::SQUARE:
            return Room(x, y, base_size, base_size);
            
        case RoomShape::RECTANGLE:
            {
                int w = base_size + std::uniform_int_distribution<int>(-2, 4)(rng);
                int h = base_size + std::uniform_int_distribution<int>(-2, 4)(rng);
                return Room(x, y, w, h);
            }
            
        case RoomShape::CROSS:
            // Create cross shape by carving two overlapping rectangles
            // Implementation details...
            break;
            
        case RoomShape::CIRCLE:
            // Approximate circle with diamond or octagon
            // Implementation details...
            break;
    }
}
```

### 5.1.4 Room Validation

**Validation Functions:**

```cpp
class RoomValidator {
public:
    // Check if room placement is valid
    static bool isValidPlacement(const Room& room, const Map& map) {
        // Check map boundaries
        if (room.x < 1 || room.y < 1) return false;
        if (room.right() >= map.getWidth() - 1) return false;
        if (room.bottom() >= map.getHeight() - 1) return false;
        
        // Check minimum size
        if (room.width < MIN_ROOM_SIZE || room.height < MIN_ROOM_SIZE) {
            return false;
        }
        
        // Check maximum size
        if (room.width > MAX_ROOM_SIZE || room.height > MAX_ROOM_SIZE) {
            return false;
        }
        
        return true;
    }
    
    // Calculate room quality metrics
    static float calculateRoomQuality(const std::vector<Room>& rooms) {
        if (rooms.empty()) return 0.0f;
        
        // Metrics to consider:
        // - Room count vs target
        // - Average room size
        // - Room distribution (not all clustered)
        // - Size variety
        
        float quality = 1.0f;
        
        // Penalize too few rooms
        if (rooms.size() < MIN_ROOMS) {
            quality *= (float)rooms.size() / MIN_ROOMS;
        }
        
        // Calculate average room size
        int total_area = 0;
        for (const auto& room : rooms) {
            total_area += room.area();
        }
        float avg_area = (float)total_area / rooms.size();
        
        // Ideal average area
        float ideal_area = (MIN_ROOM_SIZE + MAX_ROOM_SIZE) * 
                          (MIN_ROOM_SIZE + MAX_ROOM_SIZE) / 4.0f;
        
        // Penalize deviation from ideal size
        float size_factor = 1.0f - std::abs(avg_area - ideal_area) / ideal_area;
        quality *= size_factor;
        
        return quality;
    }
};
```

## Testing Requirements

### 5.1.1 Unit Tests

**File:** `tests/test_room_generation.cpp`

```cpp
TEST_CASE("Room: Basic properties", "[room]") {
    Room room(10, 15, 8, 6);
    
    SECTION("Dimensions") {
        REQUIRE(room.x == 10);
        REQUIRE(room.y == 15);
        REQUIRE(room.width == 8);
        REQUIRE(room.height == 6);
    }
    
    SECTION("Boundaries") {
        REQUIRE(room.left() == 10);
        REQUIRE(room.right() == 17);
        REQUIRE(room.top() == 15);
        REQUIRE(room.bottom() == 20);
    }
    
    SECTION("Center calculation") {
        Point center = room.center();
        REQUIRE(center.x == 14);  // 10 + 8/2
        REQUIRE(center.y == 18);  // 15 + 6/2
    }
}

TEST_CASE("Room: Overlap detection", "[room]") {
    Room room1(10, 10, 5, 5);
    
    SECTION("Overlapping rooms") {
        Room room2(12, 12, 5, 5);  // Overlaps
        REQUIRE(room1.overlaps(room2) == true);
    }
    
    SECTION("Adjacent rooms") {
        Room room2(15, 10, 5, 5);  // Touching but not overlapping
        REQUIRE(room1.overlaps(room2) == false);
        REQUIRE(room1.overlaps(room2, 1) == true);  // With padding
    }
    
    SECTION("Distant rooms") {
        Room room2(20, 20, 5, 5);  // Far apart
        REQUIRE(room1.overlaps(room2) == false);
    }
}

TEST_CASE("Room generation: Random placement", "[map_generator]") {
    Map map(80, 24);
    std::mt19937 rng(12345);  // Fixed seed for reproducibility
    
    auto rooms = MapGenerator::generateRooms(map, rng);
    
    SECTION("Room count") {
        REQUIRE(rooms.size() >= 8);
        REQUIRE(rooms.size() <= 15);
    }
    
    SECTION("No overlaps") {
        for (size_t i = 0; i < rooms.size(); i++) {
            for (size_t j = i + 1; j < rooms.size(); j++) {
                REQUIRE(rooms[i].overlaps(rooms[j]) == false);
            }
        }
    }
    
    SECTION("All rooms carved") {
        for (const auto& room : rooms) {
            // Check that room interior is floor
            Point center = room.center();
            REQUIRE(map.getTile(center.x, center.y) == TileType::FLOOR);
        }
    }
}
```

### 5.1.2 Integration Tests

- Generate 100 dungeons and verify all have valid room counts
- Test room generation with different map sizes
- Verify room generation performance (< 100ms for standard map)
- Test edge cases (very small maps, very large maps)

## Documentation Requirements

### API Documentation

```cpp
/**
 * @brief Generate random rooms for dungeon layout
 * @param map The map to generate rooms in
 * @param rng Random number generator for reproducible generation
 * @return Vector of generated rooms for corridor connection
 */
std::vector<Room> generateRooms(Map& map, std::mt19937& rng);
```

### Algorithm Documentation

Document the room generation algorithm in detail:

1. Random room size selection within constraints
2. Random position selection
3. Overlap detection with padding
4. Room carving into map
5. Retry logic and attempt limits

## Performance Considerations

### Current Implementation

- O(nÂ²) overlap checking for n rooms
- Acceptable for small room counts (< 50)
- Simple rectangle-rectangle collision detection

### Optimization Opportunities

- Spatial partitioning for faster overlap checks
- BSP tree for guaranteed non-overlapping rooms
- Pre-calculate valid placement zones
- Early exit when sufficient rooms placed

## Acceptance Criteria

### Functional Requirements

- [ ] Generate 8-15 rooms per map
- [ ] Room sizes between 4x4 and 12x12
- [ ] No overlapping rooms (with 2-tile padding)
- [ ] All rooms have proper walls
- [ ] Room centers calculated correctly

### Quality Requirements

- [ ] Generation completes in < 100ms
- [ ] All unit tests pass
- [ ] No memory leaks
- [ ] Reproducible with fixed seed
- [ ] Code follows project style

### Edge Cases

- [ ] Handle very small maps gracefully
- [ ] Handle maps where few rooms fit
- [ ] Handle failed placement attempts
- [ ] Ensure at least one room always generated

## Implementation Order

1. **Create Room class** with basic properties
2. **Implement overlap detection** algorithm
3. **Add random generation** with placement attempts
4. **Implement room carving** into map
5. **Add unit tests** for all functionality
6. **Integrate with MapGenerator** class
7. **Add room variety** (shapes, types)
8. **Performance optimization** if needed

## Git Workflow

```bash
# Create feature branch
git checkout -b feature/phase-5.1-room-generation

# Implement Room class
git add include/room.h src/room.cpp
git commit -m "[Phase 5.1] Implement Room class

- Add room dimensions and boundaries
- Implement overlap detection
- Add center point calculation"

# Add room generation
git add src/map_generator.cpp
git commit -m "[Phase 5.1] Add random room generation

- Implement random placement algorithm
- Add overlap checking with padding
- Ensure proper room carving"

# Add tests
git add tests/test_room_generation.cpp
git commit -m "[Phase 5.1] Add room generation tests

- Test room properties and overlap detection
- Test random generation with constraints
- Verify no overlapping rooms"

# Final integration
git checkout main
git merge feature/phase-5.1-room-generation
git tag v0.5.1-room-generation
git push origin main --tags
```

## Notes

### Current Implementation Status

- Basic room carving exists in `carveRoom()`
- Fixed room layouts used in test maps
- No Room class yet (using x, y, w, h parameters)
- No random generation implemented

### Design Decisions

- Rectangle rooms only for MVP (shapes can come later)
- 2-tile padding prevents narrow gaps between rooms
- Fixed seed support enables reproducible testing
- Simple overlap detection sufficient for room counts

### Future Enhancements

- Special room types (treasure, boss, puzzle)
- Non-rectangular room shapes
- Room themes and decoration
- Prefab room templates
- Multi-room complexes

---

*Prerequisites: Phase 3 complete*  
*Next Phase: 5.2 Corridor Generation to connect rooms*
