# Phase 0.3: Basic FTXUI Window - Detailed Implementation Guide

## Overview

This phase transitions from the basic menu created in Phase 0.2 to a proper game window layout with three panels: map area, message log, and status bar. We'll establish the UI framework that will be used throughout the game.

## Prerequisites

- Phase 0.2 completed successfully
- FTXUI working with menu system
- Terminal properly handling Unicode characters
- Build system functional

## Current State

From Phase 0.2, we have:

- A working FTXUI menu with navigation
- Quit functionality on 'q' or ESC
- Proper terminal cleanup on exit
- Yellow title box "VEYRM ROGUELIKE"

## Goals for Phase 0.3

1. Create a three-panel layout (map, log, status)
2. Implement proper game screen separate from menu
3. Add state management (Menu vs Playing)
4. Ensure Unicode characters display correctly
5. Handle window resizing gracefully

## Step-by-Step Implementation

### Step 1: Create Game State Management

Create `include/game_state.h`:

```cpp
#pragma once

enum class GameState {
    MENU,
    PLAYING,
    QUIT
};

class GameManager {
public:
    GameManager();
    
    GameState getState() const { return current_state; }
    void setState(GameState state) { current_state = state; }
    
    // Game data that will be added later
    int player_hp = 10;
    int player_max_hp = 10;
    int turn_count = 0;
    
private:
    GameState current_state = GameState::MENU;
};
```

### Step 2: Create the Game Screen Layout

Create `include/game_screen.h`:

```cpp
#pragma once
#include <ftxui/component/component.hpp>
#include <ftxui/component/screen_interactive.hpp>
#include "game_state.h"

class GameScreen {
public:
    GameScreen(GameManager* manager, ftxui::ScreenInteractive* screen);
    ftxui::Component Create();
    
private:
    GameManager* game_manager;
    ftxui::ScreenInteractive* screen;
    
    // UI components
    ftxui::Component CreateMapPanel();
    ftxui::Component CreateLogPanel();
    ftxui::Component CreateStatusPanel();
};
```

### Step 3: Implement Game Screen Layout

Create `src/game_screen.cpp`:

```cpp
#include "game_screen.h"
#include <ftxui/component/component.hpp>
#include <ftxui/dom/elements.hpp>

using namespace ftxui;

GameScreen::GameScreen(GameManager* manager, ScreenInteractive* scr) 
    : game_manager(manager), screen(scr) {}

Component GameScreen::CreateMapPanel() {
    return Renderer([] {
        // Temporary test map display
        std::vector<Element> map_lines;
        
        // Create a simple test room
        for (int y = 0; y < 20; y++) {
            std::string line;
            for (int x = 0; x < 60; x++) {
                if (y == 0 || y == 19 || x == 0 || x == 59) {
                    line += "#";  // Walls
                } else if (x == 30 && y == 10) {
                    line += "@";  // Player
                } else {
                    line += ".";  // Floor
                }
            }
            map_lines.push_back(text(line));
        }
        
        return vbox(map_lines) | border | size(WIDTH, EQUAL, 62) | size(HEIGHT, EQUAL, 22);
    });
}

Component GameScreen::CreateLogPanel() {
    return Renderer([] {
        return vbox({
            text("Welcome to Veyrm!"),
            text("You descend into the Spiral Vaults..."),
            text(""),
            text(""),
            text("Press ? for help, q to quit")
        }) | border | size(HEIGHT, EQUAL, 7);
    });
}

Component GameScreen::CreateStatusPanel() {
    return Renderer([this] {
        return hbox({
            text("HP: " + std::to_string(game_manager->player_hp) + "/" + 
                 std::to_string(game_manager->player_max_hp)) | bold,
            separator(),
            text("Turn: " + std::to_string(game_manager->turn_count)),
            separator(),
            text("Depth: 1"),
        }) | border | size(HEIGHT, EQUAL, 3);
    });
}

Component GameScreen::Create() {
    auto map_panel = CreateMapPanel();
    auto log_panel = CreateLogPanel();
    auto status_panel = CreateStatusPanel();
    
    // Main game layout
    auto layout = Container::Vertical({
        Container::Horizontal({
            map_panel,
            Container::Vertical({
                status_panel,
                log_panel
            })
        })
    });
    
    // Add input handling
    layout |= CatchEvent([this](Event event) {
        if (event == Event::Character('q') || event == Event::Escape) {
            game_manager->setState(GameState::MENU);
            return true;
        }
        
        // Movement keys (placeholder for now)
        if (event == Event::ArrowUp || event == Event::Character('k')) {
            // Move up
            return true;
        }
        if (event == Event::ArrowDown || event == Event::Character('j')) {
            // Move down
            return true;
        }
        if (event == Event::ArrowLeft || event == Event::Character('h')) {
            // Move left
            return true;
        }
        if (event == Event::ArrowRight || event == Event::Character('l')) {
            // Move right
            return true;
        }
        
        return false;
    });
    
    return Renderer(layout, [=] {
        return hbox({
            map_panel->Render(),
            vbox({
                status_panel->Render(),
                log_panel->Render()
            })
        });
    });
}
```

### Step 4: Update Main Menu to Transition to Game

Update the menu in `src/main.cpp` to handle state transitions:

```cpp
// Add to includes
#include "game_state.h"
#include "game_screen.h"

// Modify runInterface function
void runInterface() {
    using namespace ftxui;
    
    auto screen = ScreenInteractive::TerminalOutput();
    GameManager game_manager;
    
    Component active_component;
    
    // Create components
    Component main_menu = createMainMenu(&game_manager, &screen);
    GameScreen game_screen(&game_manager, &screen);
    Component game_component = game_screen.Create();
    
    // State-based renderer
    auto main_renderer = Renderer([&] {
        switch(game_manager.getState()) {
            case GameState::MENU:
                return main_menu->Render();
            case GameState::PLAYING:
                return game_component->Render();
            case GameState::QUIT:
                screen.ExitLoopClosure()();
                return text("Exiting...");
        }
        return text("Unknown state");
    });
    
    // State-based input handler
    auto main_component = CatchEvent(main_renderer, [&](Event event) {
        switch(game_manager.getState()) {
            case GameState::MENU:
                return main_menu->OnEvent(event);
            case GameState::PLAYING:
                return game_component->OnEvent(event);
            default:
                return false;
        }
    });
    
    screen.Loop(main_component);
    
    // Terminal cleanup remains the same
    std::cout << "\033[?1003l";
    std::cout << "\033[?1006l";
    std::cout << "\033[?1015l";
    std::cout << "\033[?1000l";
    std::cout << "\033[?25h";
    std::cout.flush();
    
    std::cout << "Thanks for playing Veyrm!\n";
}
```

### Step 5: Update CMakeLists.txt

Add the new source files to `CMakeLists.txt`:

```cmake
# Update the main executable sources
add_executable(veyrm 
    src/main.cpp
    src/game_screen.cpp
)

# Ensure include directory is set
target_include_directories(veyrm PRIVATE ${CMAKE_SOURCE_DIR}/include)
```

### Step 6: Test Unicode Support

Add Unicode box-drawing characters to the layout:

```cpp
// In game_screen.cpp, update borders to use Unicode
return vbox(map_lines) | 
    borderStyled(ROUNDED) |  // Or DOUBLE, HEAVY, etc.
    size(WIDTH, EQUAL, 62) | 
    size(HEIGHT, EQUAL, 22);
```

Test characters:

- Box drawing: ┌─┐│└┘ ╔═╗║╚╝
- Game symbols: @ # . > < † ☠ ♦ ♠
- Ensure these display correctly

## Testing Checklist

### Functionality Tests

- [ ] Menu displays and allows navigation
- [ ] "New Game" transitions to game screen
- [ ] Game screen shows three panels
- [ ] Map panel displays test room
- [ ] Status panel shows HP and turn count
- [ ] Message log shows welcome text
- [ ] 'q' returns to menu from game
- [ ] ESC returns to menu from game
- [ ] Terminal resets properly on exit

### Layout Tests

- [ ] Panels are properly sized
- [ ] Borders display correctly
- [ ] Unicode characters render properly
- [ ] Layout maintains proportions
- [ ] No overlap between panels
- [ ] Text stays within panel bounds

### State Management Tests

- [ ] State transitions work correctly
- [ ] No crashes during state changes
- [ ] Input routing works per state
- [ ] Memory is managed properly

## Common Issues and Solutions

### Unicode Display Problems

**Problem:** Box characters show as question marks or wrong symbols

**Solution:**

```cpp
// Ensure UTF-8 locale
std::locale::global(std::locale("en_US.UTF-8"));

// For Windows
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
#endif
```

### Panel Sizing Issues

**Problem:** Panels don't fit or overlap

**Solution:**

```cpp
// Use flexible sizing
auto map = ... | flex;
auto sidebar = ... | size(WIDTH, EQUAL, 20);
```

### State Transition Crashes

**Problem:** Crash when switching between menu and game

**Solution:**

- Ensure components are created before use
- Don't store references to temporary objects
- Use shared_ptr for component management

## Validation Commands

```bash
# Build and test
./build.sh clean build
./build/bin/veyrm

# Test sequence:
# 1. Launch game - menu should appear
# 2. Select "New Game" - game screen should appear
# 3. Press 'q' - should return to menu
# 4. Press 'q' again - should exit cleanly

# Check for memory leaks (macOS/Linux)
valgrind --leak-check=full ./build/bin/veyrm

# Check terminal state after exit
echo "Terminal test" # Should display normally
```

## Git Completion

```bash
# Create feature branch
git checkout -b feature/phase-0.3-ftxui-window

# After implementation
git add .
git commit -m "[Phase 0.3] Implement basic FTXUI game window

- Created three-panel layout (map, log, status)
- Added game state management (Menu/Playing/Quit)
- Implemented state transitions
- Set up proper Unicode support
- Added input handling framework
- Tests: Layout displays correctly, state transitions work
- Docs: Created detailed phase documentation"

# Tag
git tag v0.0.3-ftxui-window

# Merge to main
git checkout main
git merge feature/phase-0.3-ftxui-window

# Push
git push origin main --tags
```

## Implementation Status

✅ **PHASE 0.3 COMPLETED** - All objectives achieved and bugs fixed:

### Completed Items

1. ✅ Created game state management (`include/game_state.h`)
   - GameState enum with MENU, PLAYING, QUIT states
   - GameManager class for state tracking

2. ✅ Implemented three-panel game layout (`include/game_screen.h`, `src/game_screen.cpp`)
   - Map panel (62x22) with test room display
   - Status panel showing HP and turn count
   - Message log panel with welcome messages

3. ✅ Updated main.cpp with state transitions
   - Menu properly transitions to game on "New Game"
   - Game returns to menu on 'q' or ESC
   - State-based rendering and input routing

4. ✅ Fixed critical bugs
   - Resolved segmentation fault in menu renderer (lambda capture issue)
   - Fixed terminal mouse tracking artifacts with comprehensive cleanup
   - Added signal handlers for clean shutdown

5. ✅ Enhanced terminal handling
   - Added `resetTerminal()` function for comprehensive cleanup
   - Implemented `std::atexit()` and signal handlers
   - Disabled FTXUI mouse tracking with `screen.TrackMouse(false)`
   - Updated build.sh with terminal reset functionality

## Success Criteria

✅ Phase 0.3 is complete when:

1. ✅ Three-panel game layout displays correctly
2. ✅ State management allows menu ↔ game transitions
3. ✅ Unicode characters render properly
4. ✅ Basic input handling framework in place
5. ✅ No memory leaks or crashes
6. ✅ Terminal cleanup still works
7. ✅ Code is committed and tagged as v0.0.3-ftxui-window

## Next Phase

Once this phase is complete, proceed to:
**Phase 1.1: Game State Structure** - Formalize the game state and input handling system
