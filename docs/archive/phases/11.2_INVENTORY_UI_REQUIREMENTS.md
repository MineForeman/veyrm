# Phase 11.2: Inventory UI Requirements

## Overview

Phase 11.2 implements the user interface for the inventory system created in Phase 11.1. This includes displaying the inventory screen, navigating items, and providing visual feedback for inventory operations.

## Goals

1. Create an intuitive inventory display screen
2. Implement keyboard navigation for inventory
3. Show item details and stack counts
4. Support item selection for actions (use, drop, examine)
5. Integrate with existing game UI flow

## Technical Requirements

### 1. Inventory Screen Component

Create `include/inventory_screen.h` and `src/inventory_screen.cpp`:

```cpp
class InventoryScreen : public ftxui::ComponentBase {
public:
    InventoryScreen(Player* player, GameState* game_state);

    // Component interface
    ftxui::Element Render() override;
    bool OnEvent(ftxui::Event event) override;

    // State management
    void Open();
    void Close();
    bool IsOpen() const { return is_open; }

    // Item selection
    int GetSelectedSlot() const { return selected_slot; }
    Item* GetSelectedItem() const;

private:
    Player* player;
    GameState* game_state;
    bool is_open;
    int selected_slot;
    int scroll_offset;

    // UI helpers
    ftxui::Element RenderItemList();
    ftxui::Element RenderItemDetails();
    ftxui::Element RenderActions();
    void HandleItemSelection(int slot);
    void HandleAction(InventoryAction action);
};
```

### 2. Display Layout

The inventory screen should use a multi-panel layout:

```
╭─────────────────────────────────────────────────╮
│              INVENTORY (26/26 slots)            │
├─────────────────────────────────────────────────┤
│ a) Iron Sword                         1   5 lb │
│ b) Leather Armor                      1  10 lb │
│ c) Minor Healing Potion (x3)          3   1 lb │
│ d) Arrows (x45)                      45   2 lb │
│ e) Scroll of Identify                 1   0 lb │
│ f) Gold Coins                       125   0 lb │
│ g) [empty]                                      │
│ ...                                             │
├─────────────────────────────────────────────────┤
│ Selected: Iron Sword                            │
│ Type: Weapon                                    │
│ Weight: 5 lbs                                   │
│ Value: 50 gold                                  │
│ Description: A sturdy iron sword.               │
├─────────────────────────────────────────────────┤
│ [u]se [d]rop [e]xamine [ESC]back                │
╰─────────────────────────────────────────────────╯
```

### 3. Input Handling

Update `InputHandler` to support inventory navigation:

```cpp
enum class InputAction {
    // ... existing actions
    OPEN_INVENTORY,      // 'i' key
    CLOSE_INVENTORY,     // ESC or 'i' again
    SELECT_ITEM,         // a-z keys or arrow navigation
    USE_ITEM,            // 'u' key
    DROP_ITEM,           // 'd' key
    EXAMINE_ITEM,        // 'e' key
    SCROLL_UP,           // Page Up or '<'
    SCROLL_DOWN,         // Page Down or '>'
};
```

### 4. Game State Integration

Update `GameScreen` to handle inventory state:

```cpp
// In game_screen.cpp
case InputAction::OPEN_INVENTORY: {
    if (current_state == GameState::PLAYING) {
        previous_state = current_state;
        current_state = GameState::INVENTORY;
        inventory_screen->Open();
        return false;  // Don't consume turn
    }
    break;
}

case InputAction::CLOSE_INVENTORY: {
    if (current_state == GameState::INVENTORY) {
        current_state = previous_state;
        inventory_screen->Close();
        return false;
    }
    break;
}
```

### 5. Item List Rendering

Display items with proper formatting:

```cpp
ftxui::Element InventoryScreen::RenderItemList() {
    std::vector<ftxui::Element> items;
    auto* inventory = player->inventory.get();
    auto all_items = inventory->getAllItems();

    for (int i = 0; i < inventory->getTotalSlots(); i++) {
        char slot_letter = 'a' + i;

        if (i < all_items.size()) {
            auto* item = all_items[i];
            std::string line = fmt::format("{}) {:<30} {:>3} {:>4} lb",
                slot_letter,
                item->name,
                item->stackable ? item->stack_size : 1,
                item->weight);

            auto elem = ftxui::text(line);
            if (i == selected_slot) {
                elem = elem | ftxui::inverted;
            }
            items.push_back(elem);
        } else {
            std::string line = fmt::format("{}) [empty]", slot_letter);
            items.push_back(ftxui::text(line) | ftxui::dim);
        }
    }

    return ftxui::vbox(items);
}
```

### 6. Item Actions

Implement action handlers:

```cpp
void InventoryScreen::HandleAction(InventoryAction action) {
    auto* item = GetSelectedItem();
    if (!item) return;

    switch (action) {
        case InventoryAction::USE:
            if (item->type == Item::ItemType::POTION) {
                // Use potion
                player->heal(item->properties["heal"]);
                player->inventory->removeItem(selected_slot);
                game_state->getMessageLog()->addMessage(
                    "You drink the " + item->name + ".");
                Close();  // Return to game
            }
            break;

        case InventoryAction::DROP:
            // Drop item at player position
            auto dropped = player->inventory->removeItem(selected_slot);
            if (dropped) {
                game_state->getItemManager()->spawnItem(
                    std::move(dropped), player->x, player->y);
                game_state->getMessageLog()->addMessage(
                    "You drop the " + dropped->name + ".");
            }
            break;

        case InventoryAction::EXAMINE:
            // Show detailed description
            ShowItemDescription(item);
            break;
    }
}
```

### 7. Scrolling Support

For inventories larger than screen space:

```cpp
class InventoryScreen {
    static constexpr int VISIBLE_ROWS = 20;
    int scroll_offset = 0;

    void ScrollUp() {
        scroll_offset = std::max(0, scroll_offset - 1);
    }

    void ScrollDown() {
        int max_offset = std::max(0,
            inventory->getUsedSlots() - VISIBLE_ROWS);
        scroll_offset = std::min(max_offset, scroll_offset + 1);
    }

    // Render only visible items
    for (int i = scroll_offset;
         i < std::min(scroll_offset + VISIBLE_ROWS, total_items);
         i++) {
        // Render item
    }
};
```

### 8. Visual Feedback

Provide clear visual indicators:

- Selected item highlighted (inverted colors)
- Empty slots shown dimmed
- Stack counts for stackable items
- Weight indicators
- Color coding by item type:
  - Weapons: cyan
  - Armor: blue
  - Potions: magenta
  - Scrolls: yellow
  - Gold: yellow bold

### 9. Keyboard Shortcuts

Support multiple input methods:

- **a-z**: Direct slot selection
- **Arrow keys**: Navigate up/down
- **Page Up/Down**: Scroll inventory
- **Enter**: Use selected item
- **u**: Use item
- **d**: Drop item
- **e**: Examine item
- **ESC or i**: Close inventory
- **?**: Show help

### 10. Status Information

Display inventory statistics:

```cpp
// Header bar
std::string header = fmt::format("INVENTORY ({}/{} slots, {}/{} lbs)",
    inventory->getUsedSlots(),
    inventory->getTotalSlots(),
    inventory->getTotalWeight(),
    inventory->getMaxWeight());
```

## Implementation Steps

1. **Create UI Component**
   - InventoryScreen class
   - FTXUI component integration
   - Layout structure

2. **Add Input Handling**
   - Keyboard mappings
   - Navigation logic
   - Action processing

3. **Implement Rendering**
   - Item list display
   - Detail panel
   - Action bar

4. **Add State Management**
   - Open/close transitions
   - State preservation
   - Focus handling

5. **Implement Actions**
   - Use item functionality
   - Drop item functionality
   - Examine functionality

6. **Add Visual Polish**
   - Colors and highlighting
   - Animations (optional)
   - Sound effects (future)

7. **Write Tests**
   - UI state management
   - Action handling
   - Edge cases

## Configuration

Add to `config.yml`:

```yaml
ui:
  inventory:
    visible_rows: 20
    show_weight: true
    show_value: true
    color_by_type: true

controls:
  inventory:
    open: 'i'
    close: ['i', 'ESC']
    use: ['u', 'Enter']
    drop: 'd'
    examine: 'e'
```

## Testing Requirements

### Unit Tests

1. **State Management**
   - Open/close transitions
   - Selection tracking
   - Scroll position

2. **Action Tests**
   - Use item effects
   - Drop item placement
   - Examine display

3. **Navigation Tests**
   - Slot selection
   - Scrolling bounds
   - Keyboard shortcuts

### Manual Testing

1. Open inventory with 'i'
2. Navigate with arrows and letters
3. Use healing potions
4. Drop items
5. Examine items
6. Test with full inventory
7. Test with empty inventory
8. Verify ESC closes properly

## Success Criteria

- [ ] Inventory opens/closes smoothly
- [ ] All items display correctly
- [ ] Navigation is intuitive
- [ ] Actions work as expected
- [ ] Visual feedback is clear
- [ ] No UI glitches or crashes
- [ ] Performance is acceptable

## Future Enhancements (Post-MVP)

1. **Sorting Options**
   - Sort by type
   - Sort by weight
   - Sort by value
   - Custom ordering

2. **Filtering**
   - Show only weapons
   - Show only usable items
   - Search by name

3. **Quick Actions**
   - Quick use slots (1-9)
   - Drag and drop (mouse)
   - Multi-select

4. **Advanced Display**
   - Item comparisons
   - Equipment preview
   - Item tooltips

5. **Inventory Management**
   - Auto-sort button
   - Stack splitting
   - Item combining

## Dependencies

- Phase 11.1: Inventory Storage (COMPLETE)
- Existing FTXUI components
- Input handling system
- Game state management

## Risks and Mitigations

1. **Risk**: Complex UI state management
   - **Mitigation**: Use FTXUI's component model

2. **Risk**: Performance with many items
   - **Mitigation**: Implement viewport scrolling

3. **Risk**: Confusing navigation
   - **Mitigation**: Clear visual feedback and help text

## Notes

- Keep UI responsive during actions
- Ensure proper focus management
- Consider colorblind accessibility
- Make controls configurable
- Test on different terminal sizes
