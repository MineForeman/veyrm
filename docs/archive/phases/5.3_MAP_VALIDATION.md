# Phase 5.3: Map Validation

## Overview

Phase 5.3 implements map validation algorithms to ensure generated dungeons are playable and properly connected. This phase focuses on connectivity validation, unreachable area detection, and ensuring critical game elements are accessible.

## Current State

### What Already Exists

1. **Basic Map Generation**
   - Room generation with overlap detection
   - Multiple corridor styles (straight, L-shaped, S-shaped)
   - Connection strategies (MST, nearest, sequential)
   - Door placement system

2. **Map Structure**
   - 198x66 Angband-sized maps
   - Tile types for walls, floors, doors, stairs
   - Void spaces for uncarved areas

## Requirements

### Core Functionality

1. **Connectivity Validation**
   - [ ] Implement BFS/DFS connectivity check
   - [ ] Ensure all rooms are reachable from entrance
   - [ ] Detect isolated rooms or sections
   - [ ] Validate corridor connections

2. **Reachability Analysis**
   - [ ] Check all floor tiles are connected
   - [ ] Identify unreachable areas
   - [ ] Calculate connected components
   - [ ] Ensure stairs are reachable

3. **Map Quality Metrics**
   - [ ] Calculate total accessible area
   - [ ] Measure connectivity ratio
   - [ ] Check for dead ends
   - [ ] Validate door placement

4. **Auto-Correction**
   - [ ] Connect isolated rooms automatically
   - [ ] Remove inaccessible areas
   - [ ] Ensure minimum playable area
   - [ ] Fix door placement issues

## Implementation Tasks

### 1. Connectivity Checker
```cpp
struct ConnectivityResult {
    bool isFullyConnected;
    int numComponents;
    std::vector<std::set<Point>> components;
    std::set<Point> largestComponent;
    std::set<Point> unreachableTiles;
};

class MapValidator {
public:
    static ConnectivityResult checkConnectivity(const Map& map);
    static bool isReachable(const Map& map, const Point& from, const Point& to);
    static std::set<Point> getReachableTiles(const Map& map, const Point& start);
};
```

### 2. BFS/DFS Implementation
```cpp
// Breadth-first search for connectivity
std::set<Point> bfsFloodFill(const Map& map, const Point& start) {
    std::set<Point> visited;
    std::queue<Point> queue;
    queue.push(start);
    
    while (!queue.empty()) {
        Point current = queue.front();
        queue.pop();
        
        if (visited.count(current)) continue;
        visited.insert(current);
        
        // Check all 4 directions
        for (const auto& dir : {Point(0,-1), Point(1,0), Point(0,1), Point(-1,0)}) {
            Point next = current + dir;
            if (isWalkable(map, next) && !visited.count(next)) {
                queue.push(next);
            }
        }
    }
    return visited;
}
```

### 3. Validation Functions
```cpp
bool validateMap(Map& map) {
    // 1. Check connectivity
    auto result = checkConnectivity(map);
    if (!result.isFullyConnected) {
        // Attempt to connect components
        connectComponents(map, result.components);
    }
    
    // 2. Ensure stairs are reachable
    Point stairs = findStairs(map);
    Point start = findStartPosition(map);
    if (!isReachable(map, start, stairs)) {
        // Relocate stairs or create path
        ensureStairsReachable(map, start, stairs);
    }
    
    // 3. Check minimum playable area
    if (result.largestComponent.size() < MIN_PLAYABLE_TILES) {
        return false; // Map too small, regenerate
    }
    
    // 4. Validate doors
    validateDoorPlacement(map);
    
    return true;
}
```

### 4. Component Connection
```cpp
void connectComponents(Map& map, const std::vector<std::set<Point>>& components) {
    if (components.size() <= 1) return;
    
    // Find closest points between components
    for (size_t i = 1; i < components.size(); i++) {
        Point p1, p2;
        findClosestPoints(components[0], components[i], p1, p2);
        
        // Carve corridor between components
        carveCorridorStraight(map, p1, p2);
    }
}
```

## Testing Requirements

### Unit Tests
- [ ] Test BFS/DFS flood fill algorithm
- [ ] Test connectivity detection
- [ ] Test component identification
- [ ] Test reachability checks
- [ ] Test auto-correction functions

### Integration Tests
- [ ] Generate 100 random maps and validate
- [ ] Test maps with intentionally disconnected rooms
- [ ] Test maps with isolated areas
- [ ] Verify stairs always reachable
- [ ] Check door accessibility

### Edge Cases
- [ ] Single room maps
- [ ] Maps with no valid connections
- [ ] Maps with multiple isolated components
- [ ] Maps with inaccessible stairs

## Files to Create/Modify

1. **include/map_validator.h** (new)
   - MapValidator class definition
   - ConnectivityResult struct
   - Validation method declarations

2. **src/map_validator.cpp** (new)
   - BFS/DFS implementation
   - Connectivity checking
   - Component connection
   - Auto-correction algorithms

3. **include/map_generator.h**
   - Add validation method declarations
   - Add validation options struct

4. **src/map_generator.cpp**
   - Integrate validation into generation
   - Call validator after generation
   - Regenerate if validation fails

5. **tests/test_map_validation.cpp** (new)
   - Unit tests for validation algorithms
   - Integration tests for map quality
   - Edge case testing

## Dependencies

- Phase 5.1 Room Generation (✅ Complete)
- Phase 5.2 Corridor Generation (✅ Complete)
- Basic map structure (✅ Complete)
- Tile system (✅ Complete)

## Success Criteria

1. **100% Connectivity**: All generated maps fully connected
2. **Stairs Reachable**: Stairs always accessible from start
3. **No Isolated Areas**: No unreachable floor tiles
4. **Performance**: Validation completes in <10ms
5. **Auto-Correction**: 95% of maps fixable without regeneration
6. **Test Coverage**: All validation code tested

## Algorithm Details

### BFS for Connectivity
1. Start from any floor tile
2. Flood fill to all reachable tiles
3. Count unreached floor tiles
4. If any unreached, map is disconnected

### Component Detection
1. Find all floor tiles
2. Group into connected components
3. Each component is a BFS flood fill result
4. Largest component is main dungeon

### Distance Calculation
```cpp
int manhattanDistance(const Point& a, const Point& b) {
    return std::abs(a.x - b.x) + std::abs(a.y - b.y);
}

int euclideanDistanceSq(const Point& a, const Point& b) {
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return dx * dx + dy * dy;
}
```

## Future Enhancements

1. **Advanced Validation**
   - Loop detection and creation
   - Choke point identification
   - Room accessibility scoring
   - Path diversity metrics

2. **Quality Metrics**
   - Exploration interest score
   - Combat space evaluation
   - Loot distribution validation
   - Monster placement validation

3. **Performance Optimization**
   - Cached connectivity data
   - Incremental validation
   - Parallel validation checks

## Notes

- BFS is preferred over DFS for shortest path guarantees
- Validation should be fast enough to retry generation if needed
- Consider caching validation results for debugging
- Door tiles should be treated as walkable for connectivity
- Stairs must be on a floor tile and reachable