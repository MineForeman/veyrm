# Phase 12.1: Game Serialization - Requirements

## Overview
Implement a complete save/load system that allows players to persist their game state and resume play later. The system must handle all game data including map state, entities, inventory, and progress.

## Core Objectives
1. **Save Game State**: Serialize entire game state to JSON format
2. **Load Game State**: Deserialize and restore complete game state
3. **Save Management**: Handle multiple save files with metadata
4. **Error Handling**: Graceful handling of corrupted or incompatible saves
5. **Auto-save**: Periodic automatic saving to prevent progress loss

## Technical Requirements

### 1. Serialization Format
- **Format**: JSON using nlohmann/json (already in project)
- **Structure**: Hierarchical, version-tagged format
- **Compression**: Optional gzip compression for large saves
- **File Extension**: `.sav` for save files
- **Location**: `saves/` directory in project root

### 2. Save File Structure
```json
{
  "version": "0.12.1",
  "timestamp": "2025-01-14T12:00:00Z",
  "game_version": "0.11.3",
  "metadata": {
    "player_name": "Hero",
    "level": 1,
    "play_time": 3600,
    "turn_count": 1500
  },
  "game_state": {
    "current_state": "PLAYING",
    "turn": 1500,
    "seed": 12345
  },
  "map": { ... },
  "player": { ... },
  "entities": [ ... ],
  "items": [ ... ],
  "message_log": [ ... ]
}
```

## Data Components to Serialize

### 1. Game Manager State
- Current game state (MENU, PLAYING, INVENTORY, etc.)
- Turn count
- Random seed
- Game flags/settings

### 2. Map Data
- **Tiles**: 2D array of tile types
- **Visibility**: Current FOV state
- **Memory**: Explored areas
- **Properties**: Width, height, depth level
- **Room Data**: Room boundaries and connections

### 3. Player Data
- **Stats**: HP, max HP, attack, defense, speed
- **Position**: x, y coordinates
- **Inventory**: Complete inventory state
  - Items with all properties
  - Stack counts
  - Slot assignments
- **Equipment**: Equipped items (future)
- **Gold**: Current gold amount
- **Experience**: XP and level (if implemented)

### 4. Entity Data (Monsters)
- **Type**: Monster ID/species
- **Stats**: HP, max HP, attack, defense
- **Position**: x, y coordinates
- **State**: AI state, target, behavior flags
- **Unique ID**: For reference consistency

### 5. Item Data
- **World Items**: Items on the ground
  - Position (x, y)
  - Item properties
  - Stack count
- **Container Items**: Items in chests (future)

### 6. Message Log
- Recent messages (last 100-200)
- Message types/colors
- Turn timestamps

### 7. Game Statistics
- Monsters killed
- Items collected
- Floors explored
- Total damage dealt/taken
- Play time

## Implementation Components

### 1. Serializer Class
```cpp
class GameSerializer {
public:
    // Save operations
    bool saveGame(const std::string& filename);
    bool quickSave();
    bool autoSave();

    // Load operations
    bool loadGame(const std::string& filename);
    bool loadQuickSave();

    // Save management
    std::vector<SaveInfo> getSaveFiles();
    bool deleteSave(const std::string& filename);
    bool validateSave(const std::string& filename);

private:
    json serializeGameState();
    json serializeMap();
    json serializePlayer();
    json serializeEntities();
    json serializeItems();

    bool deserializeGameState(const json& data);
    bool deserializeMap(const json& data);
    bool deserializePlayer(const json& data);
    bool deserializeEntities(const json& data);
    bool deserializeItems(const json& data);
};
```

### 2. Serializable Interface
```cpp
class ISerializable {
public:
    virtual json serialize() const = 0;
    virtual bool deserialize(const json& data) = 0;
    virtual ~ISerializable() = default;
};
```

### 3. Save Info Structure
```cpp
struct SaveInfo {
    std::string filename;
    std::string timestamp;
    std::string player_name;
    int level;
    int turn_count;
    int play_time;
    bool is_valid;
    std::string version;
};
```

## User Interface Requirements

### 1. Save Menu
- List of save slots (10 slots)
- Show save metadata for each slot
- Highlight empty vs used slots
- Options: Save, Load, Delete
- Quick save slot (Slot 0)

### 2. Save Dialog
- Prompt for save slot selection
- Confirm overwrite if slot is used
- Show save progress indicator
- Success/failure message

### 3. Load Dialog
- Display available saves with metadata
- Preview save details
- Confirm load (warns about losing current progress)
- Handle missing/corrupted saves gracefully

### 4. Keybindings
- `S` (shift+s): Open save menu
- `L` (shift+l): Open load menu
- `F5`: Quick save
- `F9`: Quick load

## Edge Cases & Error Handling

### 1. Save Failures
- Disk full
- Permission denied
- Write errors
- Handle gracefully with user feedback

### 2. Load Failures
- File not found
- Corrupted data
- Version mismatch
- Missing dependencies (items, monsters)

### 3. Version Compatibility
- Detect save version
- Migrate old saves if possible
- Reject incompatible versions with clear message

### 4. Data Validation
- Validate all loaded data
- Check entity positions are valid
- Verify item references
- Ensure player state is consistent

## Auto-save Strategy

### 1. Triggers
- Every 100 turns
- On floor transition
- Before boss fights
- On quit (prompt)

### 2. Rotating Auto-saves
- Keep last 3 auto-saves
- Rotate oldest out
- Separate from manual saves

## Performance Considerations

### 1. Async Saving
- Save in background thread
- Don't block gameplay
- Show unobtrusive indicator

### 2. Incremental Saves
- Delta saves for auto-save
- Full saves for manual saves
- Compress large saves

### 3. Memory Management
- Stream large data sets
- Clear temporary data after save
- Efficient JSON generation

## Testing Requirements

### 1. Unit Tests
- Serialize/deserialize each component
- Round-trip testing (save → load → compare)
- Edge case handling
- Version migration

### 2. Integration Tests
- Full game save/load cycle
- Multiple saves management
- Save corruption recovery
- Performance under load

### 3. Manual Testing
- Save at various game states
- Load into different scenarios
- Test all UI flows
- Verify data integrity

## Security Considerations

### 1. Save File Tampering
- Optional checksum validation
- Detect modified saves
- Allow but mark as "modified"

### 2. Path Validation
- Sanitize filenames
- Prevent directory traversal
- Restrict to saves directory

## Future Enhancements

### 1. Cloud Saves
- Sync with cloud storage
- Multiple device support
- Conflict resolution

### 2. Save Sharing
- Export/import saves
- Share with other players
- Challenge modes from saves

### 3. Save Analytics
- Track save/load patterns
- Identify common quit points
- Improve auto-save timing

## Success Criteria

1. **Functionality**
   - Can save game at any point during normal gameplay
   - Can load saved game and continue exactly where left off
   - All game state is preserved perfectly

2. **Reliability**
   - No data loss on save/load
   - Handles errors gracefully
   - Validates data integrity

3. **Performance**
   - Save completes in < 500ms
   - Load completes in < 1 second
   - No gameplay interruption

4. **Usability**
   - Clear UI for save management
   - Intuitive keybindings
   - Helpful error messages

## Dependencies

### Required Before Implementation
- ✅ Phase 11: Inventory system (complete)
- ✅ Stable game state management
- ✅ nlohmann/json library integrated

### Systems to Modify
- GameManager: Add serialization methods
- All entities: Implement ISerializable
- Main menu: Add Continue option
- Game screen: Add save/load handlers

## Estimated Scope
- **Core serialization**: 4-5 hours
- **UI implementation**: 2-3 hours
- **Testing & debugging**: 2-3 hours
- **Polish & edge cases**: 1-2 hours
- **Total estimate**: 9-13 hours