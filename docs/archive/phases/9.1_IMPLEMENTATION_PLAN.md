# Phase 9.1: Combat Stats - Implementation Plan

**Phase:** 9.1 Combat Stats
**Estimated Time:** 2-3 hours
**Dependencies:** Phase 8.3 (Basic AI)
**Deliverables:** CombatSystem class, unified damage calculations, comprehensive testing

## Step-by-Step Implementation

### Step 1: Create CombatSystem Foundation (30 minutes)

#### 1.1 Create CombatSystem Header

**File:** `include/combat_system.h`

```cpp
#pragma once

#include "point.h"
#include <string>
#include <vector>
#include <memory>

class Entity;
class Player;
class Monster;
class MessageLog;

class CombatSystem {
public:
    struct CombatResult {
        bool hit = false;
        int damage = 0;
        bool critical = false;
        bool fatal = false;
        std::string attack_message;
        std::string damage_message;
        std::string result_message;
    };

    CombatSystem();
    explicit CombatSystem(MessageLog* message_log);
    ~CombatSystem() = default;

    // Core combat methods
    CombatResult processAttack(Entity& attacker, Entity& defender);
    bool calculateHit(const Entity& attacker, const Entity& defender);
    int calculateDamage(const Entity& attacker);
    void applyDamage(Entity& target, int amount);

    // Combat utilities
    int getAttackRoll(const Entity& attacker);
    int getDefenseValue(const Entity& defender);
    bool isCriticalHit(int roll);
    bool isCriticalMiss(int roll);

    // Message integration
    void setMessageLog(MessageLog* log) { message_log = log; }
    void logCombatResult(const CombatResult& result);

    // Configuration
    static const int CRITICAL_HIT_THRESHOLD = 20;
    static const int CRITICAL_MISS_THRESHOLD = 1;
    static const int BASE_DEFENSE = 10;
    static const int MIN_DAMAGE = 1;

private:
    MessageLog* message_log = nullptr;

    // Combat message generation
    std::string generateAttackMessage(const Entity& attacker, const Entity& defender, bool hit, bool critical);
    std::string generateDamageMessage(const Entity& defender, int damage, bool fatal);

    // Internal helpers
    int rollD20();
    bool isPlayer(const Entity& entity);
    bool isMonster(const Entity& entity);
    std::string getEntityName(const Entity& entity);
};
```

#### 1.2 Add to Build System

**File:** `CMakeLists.txt`

- Add `src/combat_system.cpp` to VEYRM_SOURCES

**File:** `tests/CMakeLists.txt`

- Add `test_combat_system.cpp` to test sources
- Add `${CMAKE_SOURCE_DIR}/src/combat_system.cpp` to test dependencies

### Step 2: Implement CombatSystem Core Logic (45 minutes)

#### 2.1 Create CombatSystem Implementation

**File:** `src/combat_system.cpp`

```cpp
#include "combat_system.h"
#include "entity.h"
#include "player.h"
#include "monster.h"
#include "message_log.h"
#include <random>
#include <algorithm>
#include <sstream>

CombatSystem::CombatSystem() : message_log(nullptr) {}

CombatSystem::CombatSystem(MessageLog* log) : message_log(log) {}

CombatSystem::CombatResult CombatSystem::processAttack(Entity& attacker, Entity& defender) {
    CombatResult result;

    // Calculate hit chance
    result.hit = calculateHit(attacker, defender);

    if (result.hit) {
        // Calculate damage
        result.damage = calculateDamage(attacker);

        // Check for critical hit
        int attack_roll = getAttackRoll(attacker);
        result.critical = isCriticalHit(attack_roll);
        if (result.critical) {
            result.damage *= 2; // Double damage on critical
        }

        // Apply damage
        int old_hp = defender.hp;
        applyDamage(defender, result.damage);
        result.fatal = (defender.hp <= 0);

        // Generate messages
        result.attack_message = generateAttackMessage(attacker, defender, true, result.critical);
        result.damage_message = generateDamageMessage(defender, result.damage, result.fatal);
    } else {
        // Miss
        result.attack_message = generateAttackMessage(attacker, defender, false, false);
    }

    // Log the result
    if (message_log) {
        logCombatResult(result);
    }

    return result;
}

bool CombatSystem::calculateHit(const Entity& attacker, const Entity& defender) {
    int attack_roll = getAttackRoll(attacker);
    int defense_value = getDefenseValue(defender);

    // Critical hit always hits
    if (isCriticalHit(attack_roll)) {
        return true;
    }

    // Critical miss always misses
    if (isCriticalMiss(attack_roll)) {
        return false;
    }

    // Standard hit calculation
    return attack_roll >= defense_value;
}

// ... rest of implementation
```

#### 2.2 Implement Helper Methods

- `calculateDamage()`: Unified damage calculation with randomness
- `getAttackRoll()`: Standard d20 + attack bonus
- `getDefenseValue()`: Base 10 + defense stat
- `generateAttackMessage()`: Descriptive combat messages
- `generateDamageMessage()`: Damage result messages

### Step 3: Update Entity Interface (30 minutes)

#### 3.1 Enhance Entity Base Class

**File:** `include/entity.h`

```cpp
// Add to Entity class
public:
    // Combat interface
    virtual int getAttackBonus() const;
    virtual int getDefenseBonus() const;
    virtual int getBaseDamage() const;
    virtual std::string getCombatName() const;

    // Combat events (for future extensibility)
    virtual void onAttack(Entity& target) {}
    virtual void onHit(Entity& attacker, int damage) {}
    virtual void onMiss(Entity& attacker) {}
    virtual void onDeath() {}
```

#### 3.2 Update Player Class

**File:** `include/player.h` & `src/player.cpp`

```cpp
// Override combat interface
int getAttackBonus() const override { return attack; }
int getDefenseBonus() const override { return defense; }
int getBaseDamage() const override { return attack; }
std::string getCombatName() const override { return "You"; }

// Add player-specific combat methods
int calculatePlayerDamage() const;
bool hasWeaponEquipped() const { return false; } // For future equipment
```

#### 3.3 Update Monster Class

**File:** `include/monster.h` & `src/monster.cpp`

```cpp
// Override combat interface
int getAttackBonus() const override { return attack; }
int getDefenseBonus() const override { return defense; }
int getBaseDamage() const override { return attack; }
std::string getCombatName() const override { return name; }

// Update existing methods to use CombatSystem
// Keep backward compatibility for AI system
```

### Step 4: Integration with Game Systems (30 minutes)

#### 4.1 Integrate with GameManager

**File:** `include/game_state.h`

```cpp
#include "combat_system.h"

class GameManager {
    // ... existing members ...
    std::unique_ptr<CombatSystem> combat_system;

public:
    // ... existing methods ...
    CombatSystem* getCombatSystem() { return combat_system.get(); }
    void processCombat(Entity& attacker, Entity& defender);
};
```

**File:** `src/game_manager.cpp`

```cpp
// In constructor
combat_system(std::make_unique<CombatSystem>(message_log.get()))

// Update monster AI integration
void GameManager::updateMonsters() {
    // ... existing code ...

    // Check if the move is valid (not blocked by another entity)
    if (next_pos != monster->getPosition()) {
        // Check if player is at target position (attack)
        if (next_pos == player->getPosition()) {
            // Use CombatSystem for attack
            auto result = combat_system->processAttack(*monster, *player);
            continue;
        }
        // ... rest of movement logic
    }
}
```

#### 4.2 Update AI System Integration

**File:** `src/monster_ai.cpp`

```cpp
// Update combat decision making to consider CombatSystem
// AI can evaluate combat effectiveness using new system
// Modify flee behavior based on combat stats
```

### Step 5: Comprehensive Testing (30 minutes)

#### 5.1 Create Unit Tests

**File:** `tests/test_combat_system.cpp`

```cpp
#include <catch2/catch_test_macros.hpp>
#include "combat_system.h"
#include "player.h"
#include "monster.h"
#include "message_log.h"

TEST_CASE("CombatSystem Basic Functionality", "[combat]") {
    CombatSystem combat;
    Player player(5, 5);

    // Create test monster
    Monster monster(6, 5, "test_orc");
    monster.setStats(10, 10, 5, 2, 100, 10);

    SECTION("Attack roll calculation") {
        int roll = combat.getAttackRoll(player);
        REQUIRE(roll >= 1);
        REQUIRE(roll <= 20 + player.attack);
    }

    SECTION("Defense value calculation") {
        int defense = combat.getDefenseValue(monster);
        REQUIRE(defense == 10 + monster.defense);
    }

    SECTION("Damage calculation") {
        int damage = combat.calculateDamage(player);
        REQUIRE(damage >= 1);
        REQUIRE(damage <= player.attack);
    }

    SECTION("Combat result structure") {
        auto result = combat.processAttack(player, monster);
        REQUIRE((result.hit == true || result.hit == false));
        if (result.hit) {
            REQUIRE(result.damage >= 1);
            REQUIRE(!result.attack_message.empty());
            REQUIRE(!result.damage_message.empty());
        }
    }
}

TEST_CASE("Combat Integration", "[combat]") {
    MessageLog log;
    CombatSystem combat(&log);

    SECTION("Message log integration") {
        Player player(5, 5);
        Monster monster(6, 5, "test_rat");
        monster.setStats(5, 5, 2, 0, 100, 5);

        auto result = combat.processAttack(player, monster);

        // Verify messages were logged
        auto messages = log.getMessages();
        REQUIRE(!messages.empty());
    }
}

TEST_CASE("Critical Hits and Misses", "[combat]") {
    CombatSystem combat;

    SECTION("Critical hit detection") {
        REQUIRE(combat.isCriticalHit(20) == true);
        REQUIRE(combat.isCriticalHit(19) == false);
    }

    SECTION("Critical miss detection") {
        REQUIRE(combat.isCriticalMiss(1) == true);
        REQUIRE(combat.isCriticalMiss(2) == false);
    }
}
```

#### 5.2 Integration Tests

- Test combat with AI system
- Test combat with multiple monsters
- Test player vs monster combat scenarios
- Test critical hit/miss edge cases
- Performance testing with 30+ combatants

### Step 6: Performance and Balance Testing (15 minutes)

#### 6.1 Performance Validation

```cpp
TEST_CASE("Combat Performance", "[combat][performance]") {
    CombatSystem combat;
    Player player(5, 5);
    std::vector<Monster> monsters;

    // Create 50 monsters for stress testing
    for (int i = 0; i < 50; ++i) {
        monsters.emplace_back(i % 10, i / 10, "test_monster");
        monsters.back().setStats(10, 10, 3, 1, 100, 5);
    }

    // Time 1000 combat rounds
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 1000; ++i) {
        auto& target = monsters[i % monsters.size()];
        auto result = combat.processAttack(player, target);
    }
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    REQUIRE(duration.count() < 10000); // < 10ms for 1000 attacks
}
```

#### 6.2 Balance Testing

- Verify hit rates are reasonable (50-80% range)
- Test damage ranges are appropriate
- Ensure critical hits occur at ~5% rate
- Validate defense mitigation is meaningful

## File Modification Summary

### New Files Created

- `include/combat_system.h` - Combat system interface
- `src/combat_system.cpp` - Combat system implementation
- `tests/test_combat_system.cpp` - Comprehensive unit tests

### Modified Files

- `CMakeLists.txt` - Add combat_system.cpp to build
- `tests/CMakeLists.txt` - Add test file and dependencies
- `include/entity.h` - Add combat interface methods
- `src/entity.cpp` - Implement base combat methods
- `include/player.h` - Add combat method overrides
- `src/player.cpp` - Implement player combat methods
- `include/monster.h` - Add combat method overrides (maintain compatibility)
- `src/monster.cpp` - Update combat integration
- `include/game_state.h` - Add CombatSystem integration
- `src/game_manager.cpp` - Integrate combat with monster AI

## Success Criteria

### Functional Requirements ✅

- [ ] CombatSystem class created with full API
- [ ] All damage calculations use unified system
- [ ] Hit/miss mechanics work with d20 system
- [ ] Critical hits occur at 5% rate (natural 20)
- [ ] Combat messages integrate with message log
- [ ] AI system works with new combat system

### Technical Requirements ✅

- [ ] All unit tests pass (>95% code coverage)
- [ ] Performance: <1ms per combat resolution
- [ ] Memory: No leaks in combat processing
- [ ] Integration: Existing AI behavior preserved
- [ ] Compatibility: Existing save files still work

### Quality Requirements ✅

- [ ] Code follows project style guidelines
- [ ] Comprehensive error handling
- [ ] Clear separation of concerns
- [ ] Extensible for future features
- [ ] Well-documented API

## Risk Mitigation

### Technical Risks

- **Performance Impact**: Monitor turn processing time during implementation
- **AI Integration**: Test thoroughly with existing monster behaviors
- **Balance Changes**: Validate damage scaling with automated tests

### Implementation Risks

- **Scope Creep**: Focus only on core combat stats, defer advanced features
- **Integration Complexity**: Build incrementally and test each component
- **Testing Coverage**: Use both unit and integration tests extensively

## Next Phase Preparation

Phase 9.1 sets up the foundation for:

- **Phase 9.2**: Bump-to-attack implementation using CombatSystem
- **Phase 9.3**: Death handling with proper combat integration
- **Future Phases**: Equipment system, status effects, advanced combat mechanics

The CombatSystem provides a solid, extensible foundation that will support all future combat enhancements while maintaining performance and clean code architecture.
