# Phase 3.1: Entity Base

## Overview

Establish the foundation for all game entities (player, monsters, items) with a flexible component-based entity system. This phase creates the core Entity class and basic components that will be used throughout the game.

## Goals

1. Create a flexible entity system that can represent player, monsters, and items
2. Implement position and rendering components
3. Establish entity management patterns
4. Prepare for future entity features (AI, inventory, combat)

## Technical Design

### Core Entity System

```cpp
// Base entity class
class Entity {
public:
    Entity(int x, int y, char glyph, Color color, const std::string& name);
    virtual ~Entity() = default;
    
    // Position
    int x, y;
    
    // Rendering
    char glyph;
    Color color;
    
    // Properties
    std::string name;
    bool blocks_movement = false;
    bool blocks_sight = false;
    
    // Component flags
    bool is_player = false;
    bool is_monster = false;
    bool is_item = false;
    
    // Actions
    virtual void move(int dx, int dy);
    virtual void update(double delta_time);
    virtual void render() const;
};
```

### Player Entity

```cpp
class Player : public Entity {
public:
    Player(int x, int y);
    
    // Stats
    int hp = 10;
    int max_hp = 10;
    int attack = 1;
    int defense = 0;
    
    // Inventory (future)
    std::vector<std::shared_ptr<Entity>> inventory;
    
    // Player-specific methods
    bool tryMove(Map& map, int dx, int dy);
    void takeDamage(int amount);
    void heal(int amount);
};
```

### Monster Entity (Placeholder)

```cpp
class Monster : public Entity {
public:
    Monster(int x, int y, const MonsterDef& def);
    
    // Stats from definition
    int hp;
    int max_hp;
    int attack;
    int defense;
    
    // AI state (future)
    enum AIState {
        IDLE,
        WANDERING,
        CHASING,
        FLEEING
    };
    AIState ai_state = IDLE;
};
```

### Item Entity (Placeholder)

```cpp
class Item : public Entity {
public:
    Item(int x, int y, const ItemDef& def);
    
    // Item properties
    enum ItemType {
        WEAPON,
        ARMOR,
        CONSUMABLE,
        KEY,
        TREASURE
    };
    ItemType type;
    
    // Effects (future)
    int value = 0;
    int bonus = 0;
};
```

## Entity Management

### EntityManager Class

```cpp
class EntityManager {
public:
    // Entity lifecycle
    std::shared_ptr<Entity> createEntity(EntityType type, int x, int y);
    void destroyEntity(std::shared_ptr<Entity> entity);
    void clear();
    
    // Access
    std::shared_ptr<Player> getPlayer() { return player; }
    std::vector<std::shared_ptr<Entity>> getEntitiesAt(int x, int y);
    std::shared_ptr<Entity> getBlockingEntityAt(int x, int y);
    
    // Updates
    void updateAll(double delta_time);
    void renderAll(MapRenderer& renderer);
    
private:
    std::shared_ptr<Player> player;
    std::vector<std::shared_ptr<Entity>> entities;
    std::vector<std::shared_ptr<Monster>> monsters;
    std::vector<std::shared_ptr<Item>> items;
};
```

### Integration with GameManager

```cpp
class GameManager {
    // Replace player_x, player_y with entity system
    std::unique_ptr<EntityManager> entity_manager;
    
    void initializeEntities() {
        entity_manager = std::make_unique<EntityManager>();
        
        // Create player at spawn point
        Point spawn = MapGenerator::getDefaultSpawnPoint(map_type);
        auto player = entity_manager->createEntity(EntityType::PLAYER, spawn.x, spawn.y);
    }
    
    void handleMovement(int dx, int dy) {
        auto player = entity_manager->getPlayer();
        if (player->tryMove(*map, dx, dy)) {
            // Movement successful, process turn
            processTurn();
        }
    }
};
```

## Rendering Integration

### Update MapRenderer

```cpp
class MapRenderer {
    void renderEntities(const EntityManager& entities) {
        // Render items first (bottom layer)
        for (const auto& item : entities.getItems()) {
            if (isInViewport(item->x, item->y)) {
                renderEntity(*item);
            }
        }
        
        // Render monsters
        for (const auto& monster : entities.getMonsters()) {
            if (isInViewport(monster->x, monster->y)) {
                renderEntity(*monster);
            }
        }
        
        // Render player last (top layer)
        auto player = entities.getPlayer();
        if (player && isInViewport(player->x, player->y)) {
            renderEntity(*player);
        }
    }
    
    void renderEntity(const Entity& entity) {
        Point screen = worldToScreen(entity.x, entity.y);
        drawGlyph(screen.x, screen.y, entity.glyph, entity.color);
    }
};
```

## Implementation Steps

### Step 1: Create Entity Base Class

1. Create `include/entity.h` with Entity class definition
2. Implement basic position and rendering properties
3. Add virtual methods for extensibility
4. Test entity creation and property access

### Step 2: Implement Player Class

1. Create `include/player.h` extending Entity
2. Set player-specific properties (glyph='@', color=white)
3. Add health and stats
4. Implement movement validation against map

### Step 3: Create EntityManager

1. Create `include/entity_manager.h`
2. Implement entity storage and lifecycle
3. Add player creation and access methods
4. Implement position queries

### Step 4: Integrate with GameManager

1. Replace `player_x, player_y` with EntityManager
2. Update movement handling to use Player entity
3. Update spawn point logic
4. Ensure save/load compatibility (future consideration)

### Step 5: Update Rendering

1. Modify MapRenderer to render entities
2. Ensure proper layering (items < monsters < player)
3. Update viewport calculations
4. Test entity visibility

## Testing Requirements

### Unit Tests

```cpp
TEST_CASE("Entity creation") {
    Entity entity(10, 20, '@', Color::White, "Test");
    REQUIRE(entity.x == 10);
    REQUIRE(entity.y == 20);
    REQUIRE(entity.glyph == '@');
    REQUIRE(entity.name == "Test");
}

TEST_CASE("Player movement") {
    Map map(80, 24);
    MapGenerator::generateTestRoom(map);
    Player player(40, 12);
    
    // Test valid movement
    REQUIRE(player.tryMove(map, 1, 0) == true);
    REQUIRE(player.x == 41);
    
    // Test blocked movement (into wall)
    player.x = 30;  // Near wall
    player.y = 2;
    REQUIRE(player.tryMove(map, 0, -1) == false);
}

TEST_CASE("EntityManager") {
    EntityManager manager;
    auto entity = manager.createEntity(EntityType::PLAYER, 10, 20);
    
    REQUIRE(manager.getPlayer() != nullptr);
    REQUIRE(manager.getEntitiesAt(10, 20).size() == 1);
    
    auto blocking = manager.getBlockingEntityAt(10, 20);
    REQUIRE(blocking != nullptr);
}
```

### Integration Tests

1. Player spawns at correct position on map
2. Player renders above floor tiles
3. Player movement respects map boundaries
4. Player movement blocked by walls
5. Entity manager properly tracks all entities

## File Structure

```
include/
    entity.h          # Base entity class
    player.h          # Player entity
    monster.h         # Monster entity (stub)
    item.h            # Item entity (stub)
    entity_manager.h  # Entity management
    entity_types.h    # Enums and type definitions

src/
    entity.cpp        # Entity implementation
    player.cpp        # Player implementation
    entity_manager.cpp # Manager implementation
```

## Success Criteria

1. ✅ Entity base class created with position and rendering
2. ✅ Player class extends Entity with game-specific properties
3. ✅ EntityManager handles entity lifecycle and queries
4. ✅ Player renders on map at correct position
5. ✅ Player movement uses entity system
6. ✅ All tests pass
7. ✅ No memory leaks (check with valgrind/sanitizers)

## Future Considerations

### Phase 3.2: Player on Map

- Visual feedback for player movement
- Smooth viewport following
- Player status display

### Phase 3.3: Basic Monsters

- Monster definitions from JSON
- Monster spawning system
- Basic AI states

### Phase 4: Combat System

- Attack/damage calculations
- Death and respawn
- Combat messages

### Phase 5: Items

- Item pickup/drop
- Inventory management
- Equipment system

## API Documentation

### Entity Class

```cpp
// Create an entity
Entity entity(x, y, glyph, color, name);

// Move entity
entity.move(dx, dy);  // Relative movement
entity.x = new_x;     // Absolute positioning

// Check properties
if (entity.blocks_movement) { /* ... */ }
if (entity.is_player) { /* ... */ }
```

### Player Class

```cpp
// Create player
Player player(spawn_x, spawn_y);

// Attempt movement (with collision checking)
if (player.tryMove(map, dx, dy)) {
    // Movement successful
}

// Health management
player.takeDamage(3);
player.heal(5);
```

### EntityManager

```cpp
// Create entities
auto player = manager.createEntity(EntityType::PLAYER, x, y);
auto monster = manager.createEntity(EntityType::MONSTER, x, y);

// Query entities
auto entities = manager.getEntitiesAt(x, y);
auto blocker = manager.getBlockingEntityAt(x, y);

// Update all entities
manager.updateAll(delta_time);
```

## Notes

- Keep the entity system simple for now - avoid over-engineering
- Focus on getting player entity working first
- Monster and item entities can be stubs initially
- Ensure clean separation between entity logic and rendering
- Consider using smart pointers for memory safety
- Plan for save/load compatibility from the start

## Implementation Summary (Completed)

### What Was Built

1. **Entity Base Class** (`entity.h`, `entity.cpp`)
   - Position tracking (x, y, prev_x, prev_y)
   - Rendering properties (glyph, color, name)
   - Movement methods (move, moveTo, canMoveTo)
   - Component flags (is_player, is_monster, is_item)
   - Collision properties (blocks_movement, blocks_sight)
   - Virtual methods for extensibility

2. **Player Class** (`player.h`, `player.cpp`)
   - Extends Entity with '@' glyph, white color
   - Stats system: HP, max HP, attack, defense
   - Level and experience system with automatic leveling
   - Movement validation with tryMove()
   - Combat methods: takeDamage(), heal()
   - Inventory placeholder for future items

3. **EntityManager Class** (`entity_manager.h`, `entity_manager.cpp`)
   - Centralized entity lifecycle management
   - Entity creation factory (createEntity, createPlayer)
   - Position queries (getEntitiesAt, getBlockingEntityAt)
   - Type-based queries (getMonsters, getItems)
   - Update system for all entities
   - Proper memory management with shared_ptr

4. **Integration with GameManager**
   - EntityManager created and initialized
   - Player entity spawned at map spawn point
   - Deprecated variables synchronized for compatibility
   - Entity updates in main game loop
   - getPlayer() accessor method

5. **Movement System Integration**
   - GameScreen updated to use Player::tryMove()
   - Collision detection through entity system
   - Viewport follows player entity
   - Movement messages in log
   - All 4 cardinal directions working

### Key Implementation Details

```cpp
// Entity creation
auto player = entity_manager->createPlayer(spawn.x, spawn.y);

// Movement with collision
if (player->tryMove(*map, entity_manager, dx, dy)) {
    game_manager->processPlayerAction(ActionSpeed::NORMAL);
    renderer->centerOn(player->x, player->y);
}

// Entity queries
auto blocking = entity_manager->getBlockingEntityAt(x, y);
auto entities = entity_manager->getEntitiesAt(x, y);
```

### Testing Results

- ✅ Build successful with no warnings
- ✅ Player entity created at spawn point
- ✅ Player renders as '@' on map
- ✅ Movement uses entity system
- ✅ Collision detection working
- ✅ Deprecated variables stay synchronized
- ✅ Memory management verified (no leaks)

### Architecture

```text
GameManager
├── EntityManager
│   ├── std::shared_ptr<Player>
│   └── std::vector<std::shared_ptr<Entity>>
│       ├── Future: Monsters
│       └── Future: Items
├── Map (collision checking)
└── Renderer (uses deprecated vars for now)
```

### Compatibility Notes

The implementation maintains backward compatibility by:

- Updating deprecated player_x, player_y in GameManager
- Supporting both entity and non-entity rendering paths
- Synchronizing stats between entity and GameManager

### Future Work

- **Phase 3.2**: Update renderer to use entities directly
- **Phase 3.3**: Implement Monster class with AI
- **Phase 4**: Combat system using entity interactions
- **Phase 5**: Item entities and inventory management

### Files Added

- `include/entity.h` - Base entity class
- `include/player.h` - Player entity class  
- `include/entity_manager.h` - Entity management
- `src/entity.cpp` - Entity implementation
- `src/player.cpp` - Player implementation
- `src/entity_manager.cpp` - Manager implementation

### Files Modified

- `include/game_state.h` - Added EntityManager
- `src/game_manager.cpp` - Integrated entities
- `src/game_screen.cpp` - Updated movement
- `CMakeLists.txt` - Added new source files

This phase is complete and provides a robust foundation for all future entity-based features.
