# Phase 11.2: UI Patterns Analysis

## Existing UI Architecture Review

### Current UI Components

#### 1. GameScreen Pattern

The game uses a custom component pattern, not FTXUI ComponentBase:

- `GameScreen` class manages the main game display
- Creates panels using `Component` return type
- Three main panels: Map, Log, Status

#### 2. Rendering Pattern

```cpp
// From game_screen.cpp
Component GameScreen::CreateMapPanel() {
    return Renderer([this] {
        return renderer->renderMapPanel();
    });
}
```

Key observations:

- Uses lambda-based Renderer components
- Delegates to dedicated renderer classes
- No direct ComponentBase inheritance

#### 3. State Management

Current state management in GameScreen:

- GameState enum (MENU, PLAYING, PAUSED, etc.)
- State transitions handled in processInput()
- Previous state tracking for returns

#### 4. Input Handling Flow

```cpp
// Simplified flow
GameScreen::OnEvent(Event event)
  -> InputHandler::processEvent(event)
  -> Returns InputAction enum
  -> GameScreen::processInput(action)
  -> State-specific handling
```

### Recommended Approach for Inventory UI

Based on the existing patterns, the inventory UI should:

#### 1. **Panel-Based Approach** (Recommended)

Create an inventory panel similar to existing panels:

```cpp
class GameScreen {
    // Add inventory panel method
    Component CreateInventoryPanel() {
        return Renderer([this] {
            if (current_state != GameState::INVENTORY) {
                return ftxui::text("");
            }
            return RenderInventory();
        });
    }

    Element RenderInventory() {
        // Build inventory UI here
        return window(text("INVENTORY"),
            vbox({
                RenderItemList(),
                separator(),
                RenderItemDetails(),
                separator(),
                RenderActionBar()
            })
        );
    }
};
```

#### 2. **State Integration**

Extend existing state system:

- Add INVENTORY to GameState enum (already exists)
- Handle in processInput() switch statement
- Use state transitions for open/close

#### 3. **Renderer Pattern**

Create dedicated inventory renderer:

```cpp
class InventoryRenderer {
public:
    InventoryRenderer(Player* player);

    Element render();
    Element renderItemList();
    Element renderItemDetails();
    Element renderActionBar();

    void setSelectedSlot(int slot);
    Item* getSelectedItem() const;

private:
    Player* player;
    int selected_slot = 0;
    int scroll_offset = 0;
};
```

#### 4. **Input Processing**

Extend existing input handler:

```cpp
// In GameScreen::processInput
case GameState::INVENTORY:
    switch (action) {
        case InputAction::MOVE_UP:
            inventory_renderer->selectPrevious();
            return false;  // Don't consume turn
        case InputAction::MOVE_DOWN:
            inventory_renderer->selectNext();
            return false;
        case InputAction::USE_ITEM:
            handleUseItem();
            return true;  // Consume turn
        // ... etc
    }
```

### Alternative Approaches (Not Recommended)

#### Why Not ComponentBase?

- Existing code doesn't use ComponentBase pattern
- Would require significant refactoring
- Inconsistent with current architecture

#### Why Not Modal/Popup?

- FTXUI modals are complex
- Would break current rendering flow
- Harder to integrate with game state

### Implementation Strategy

1. **Extend GameScreen** - Add inventory rendering methods
2. **Create InventoryRenderer** - Dedicated rendering logic
3. **Reuse Existing Patterns** - Follow current architecture
4. **Minimal Refactoring** - Work within existing system

### Code Examples from Codebase

#### Panel Creation Pattern

```cpp
// From game_screen.cpp:263
Component GameScreen::Create() {
    auto map_panel = CreateMapPanel();
    auto log_panel = CreateLogPanel();
    auto status_panel = CreateStatusPanel();

    // Inventory would be added similarly
    auto inventory_panel = CreateInventoryPanel();
}
```

#### State Handling Pattern

```cpp
// From game_screen.cpp
switch (current_state) {
    case GameState::PLAYING:
        // Game logic
        break;
    case GameState::INVENTORY:  // Add this
        // Inventory logic
        break;
}
```

#### Renderer Usage Pattern

```cpp
// From renderer.cpp
Element renderSomething() {
    return vbox({
        text("Title"),
        separator(),
        renderContent(),
        separator(),
        renderFooter()
    });
}
```

### Key Differences from Original Plan

1. **No ComponentBase** - Use Renderer pattern instead
2. **No separate InventoryScreen class** - Integrate into GameScreen
3. **Use existing Element builders** - vbox, hbox, text, separator
4. **Leverage current state machine** - Don't create new one

### Benefits of This Approach

1. **Consistency** - Matches existing code patterns
2. **Simplicity** - No new paradigms to learn
3. **Integration** - Easy to add to current system
4. **Maintainability** - Follows established conventions

### Next Steps

1. Add inventory methods to GameScreen
2. Create InventoryRenderer class
3. Extend InputHandler mappings
4. Update state handling in processInput
5. Test integration with existing systems

This approach ensures the inventory UI fits naturally into the existing architecture without requiring major refactoring.
