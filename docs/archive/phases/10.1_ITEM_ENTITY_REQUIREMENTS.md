# Phase 10.1: Item Entity Requirements

## Overview

Phase 10.1 introduces the foundational Item system to Veyrm, creating the base `Item` class and infrastructure for all game items. This phase focuses on establishing the core item architecture without implementing inventory or usage mechanics (those come in 10.2 and 10.3).

## Goals

1. Create a flexible, data-driven item system
2. Support multiple item types (potions, scrolls, equipment)
3. Load item definitions from JSON files
4. Establish item spawning on maps
5. Visual representation of items in the game world

## Core Requirements

### 1. Item Class Design

Create `include/item.h` and `src/item.cpp`:

```cpp
class Item {
public:
    // Core properties
    int x, y;                    // Position on map
    std::string id;              // Unique identifier (e.g., "potion_minor")
    std::string name;            // Display name (e.g., "Minor Healing Potion")
    std::string description;     // Item description
    char symbol;                 // Display symbol (e.g., '!')
    std::string color;           // Color name (e.g., "red", "blue")

    // Item type
    enum ItemType {
        POTION,
        SCROLL,
        WEAPON,
        ARMOR,
        FOOD,
        GOLD,
        MISC
    };
    ItemType type;

    // Properties
    int value;                   // Gold value
    int weight;                  // Weight in units
    bool stackable;              // Can stack in inventory
    int stack_size;              // Current stack size (if stackable)
    int max_stack;               // Maximum stack size

    // Effects (to be parsed from JSON)
    std::map<std::string, int> properties;  // Generic properties

    // Methods
    Item(const std::string& item_id);
    void setPosition(int x, int y);
    bool isStackable() const;
    bool canStackWith(const Item& other) const;
};
```

### 2. Item Factory

Create `include/item_factory.h` and `src/item_factory.cpp`:

```cpp
class ItemFactory {
private:
    static ItemFactory* instance;
    std::map<std::string, ItemTemplate> templates;

    struct ItemTemplate {
        std::string id;
        std::string name;
        std::string description;
        char symbol;
        std::string color;
        Item::ItemType type;
        int value;
        int weight;
        bool stackable;
        int max_stack;
        std::map<std::string, int> properties;
    };

public:
    static ItemFactory& getInstance();
    void loadFromJson(const std::string& filename);
    std::unique_ptr<Item> create(const std::string& item_id);
    bool hasTemplate(const std::string& item_id) const;
    std::vector<std::string> getItemsForDepth(int depth) const;
};
```

### 3. JSON Data Format

Create `data/items.json`:

```json
{
  "items": [
    {
      "id": "potion_minor",
      "name": "Minor Healing Potion",
      "description": "A small vial of red liquid that restores health",
      "type": "potion",
      "symbol": "!",
      "color": "red",
      "value": 50,
      "weight": 1,
      "stackable": true,
      "max_stack": 10,
      "properties": {
        "heal": 10,
        "instant": 1
      },
      "depth_range": [1, 5]
    },
    {
      "id": "potion_major",
      "name": "Major Healing Potion",
      "description": "A large flask of glowing red liquid",
      "type": "potion",
      "symbol": "!",
      "color": "bright_red",
      "value": 200,
      "weight": 2,
      "stackable": true,
      "max_stack": 5,
      "properties": {
        "heal": 50,
        "instant": 1
      },
      "depth_range": [3, 10]
    },
    {
      "id": "scroll_identify",
      "name": "Scroll of Identify",
      "description": "A parchment inscribed with mystical runes",
      "type": "scroll",
      "symbol": "?",
      "color": "white",
      "value": 100,
      "weight": 1,
      "stackable": true,
      "max_stack": 20,
      "properties": {
        "identify": 1,
        "single_use": 1
      },
      "depth_range": [1, 10]
    },
    {
      "id": "scroll_teleport",
      "name": "Scroll of Teleportation",
      "description": "A scroll that warps space around the reader",
      "type": "scroll",
      "symbol": "?",
      "color": "blue",
      "value": 150,
      "weight": 1,
      "stackable": true,
      "max_stack": 10,
      "properties": {
        "teleport": 1,
        "single_use": 1
      },
      "depth_range": [2, 10]
    },
    {
      "id": "gold_coins",
      "name": "Gold Coins",
      "description": "A pile of shiny gold coins",
      "type": "gold",
      "symbol": "$",
      "color": "yellow",
      "value": 1,
      "weight": 0,
      "stackable": true,
      "max_stack": 9999,
      "properties": {
        "amount": 1
      },
      "depth_range": [1, 100]
    },
    {
      "id": "ration",
      "name": "Food Ration",
      "description": "A wrapped package of preserved food",
      "type": "food",
      "symbol": "%",
      "color": "brown",
      "value": 10,
      "weight": 2,
      "stackable": true,
      "max_stack": 10,
      "properties": {
        "nutrition": 500,
        "single_use": 1
      },
      "depth_range": [1, 10]
    }
  ]
}
```

### 4. Item Manager

Create `include/item_manager.h` and `src/item_manager.cpp`:

```cpp
class ItemManager {
private:
    std::vector<std::unique_ptr<Item>> items;
    Map* map_ref;

public:
    ItemManager(Map* map);

    // Item management
    void spawnItem(const std::string& item_id, int x, int y);
    void spawnRandomItem(int x, int y, int depth);
    void removeItem(Item* item);
    Item* getItemAt(int x, int y);
    std::vector<Item*> getItemsAt(int x, int y);

    // Rendering
    void renderItems(const FOV& fov);

    // Cleanup
    void clear();
};
```

### 5. Integration with GameScreen

Update `include/game_screen.h`:

```cpp
class GameScreen : public Screen {
private:
    // ... existing members ...
    std::unique_ptr<ItemManager> item_manager;

public:
    // ... existing methods ...
    void spawnInitialItems();
};
```

Update `src/game_screen.cpp`:

```cpp
void GameScreen::init() {
    // ... existing initialization ...

    // Initialize item system
    ItemFactory::getInstance().loadFromJson("data/items.json");
    item_manager = std::make_unique<ItemManager>(map.get());

    // Spawn initial items
    spawnInitialItems();
}

void GameScreen::spawnInitialItems() {
    // Spawn 5-10 random items in rooms
    int item_count = 5 + (rand() % 6);

    for (int i = 0; i < item_count; i++) {
        // Find random room
        const auto& rooms = map->getRooms();
        if (!rooms.empty()) {
            const Room& room = rooms[rand() % rooms.size()];

            // Find random position in room
            int x = room.x + 1 + (rand() % (room.width - 2));
            int y = room.y + 1 + (rand() % (room.height - 2));

            // Spawn random item appropriate for depth
            item_manager->spawnRandomItem(x, y, current_depth);
        }
    }
}

void GameScreen::render() {
    // ... existing rendering ...

    // Render items (after map, before entities)
    item_manager->renderItems(*fov);

    // ... rest of rendering ...
}
```

### 6. Display Integration

Items should be rendered:

- After the map tiles
- Before entities (so monsters/player appear on top)
- Only if visible in FOV
- With appropriate colors

### 7. Color Mapping

Add to rendering system:

```cpp
// Color name to terminal color mapping
std::map<std::string, Color> color_map = {
    {"red", Color::Red},
    {"bright_red", Color::BrightRed},
    {"blue", Color::Blue},
    {"yellow", Color::Yellow},
    {"brown", Color::Brown},
    {"white", Color::White},
    {"green", Color::Green},
    {"purple", Color::Purple},
    {"cyan", Color::Cyan},
    {"orange", Color::Orange}
};
```

## Testing Requirements

### Unit Tests (`tests/test_item.cpp`)

```cpp
TEST_CASE("Item Creation", "[item]") {
    SECTION("Create item from factory") {
        ItemFactory::getInstance().loadFromJson("data/items.json");
        auto potion = ItemFactory::getInstance().create("potion_minor");

        REQUIRE(potion != nullptr);
        REQUIRE(potion->name == "Minor Healing Potion");
        REQUIRE(potion->type == Item::POTION);
        REQUIRE(potion->symbol == '!');
    }

    SECTION("Item stacking") {
        auto potion1 = ItemFactory::getInstance().create("potion_minor");
        auto potion2 = ItemFactory::getInstance().create("potion_minor");
        auto scroll = ItemFactory::getInstance().create("scroll_identify");

        REQUIRE(potion1->canStackWith(*potion2) == true);
        REQUIRE(potion1->canStackWith(*scroll) == false);
    }

    SECTION("Item properties") {
        auto potion = ItemFactory::getInstance().create("potion_minor");

        REQUIRE(potion->properties["heal"] == 10);
        REQUIRE(potion->value == 50);
        REQUIRE(potion->stackable == true);
    }
}

TEST_CASE("Item Manager", "[item]") {
    SECTION("Spawn and retrieve items") {
        Map map(100, 50);
        ItemManager manager(&map);

        manager.spawnItem("potion_minor", 10, 10);
        Item* item = manager.getItemAt(10, 10);

        REQUIRE(item != nullptr);
        REQUIRE(item->x == 10);
        REQUIRE(item->y == 10);
    }

    SECTION("Multiple items at location") {
        Map map(100, 50);
        ItemManager manager(&map);

        manager.spawnItem("potion_minor", 10, 10);
        manager.spawnItem("scroll_identify", 10, 10);

        auto items = manager.getItemsAt(10, 10);
        REQUIRE(items.size() == 2);
    }
}
```

### Integration Tests

1. **Visibility Test**: Items only render when in FOV
2. **Spawn Test**: Items spawn in valid locations (not in walls)
3. **Persistence Test**: Items remain after save/load
4. **Memory Test**: No memory leaks with item creation/destruction

## Implementation Steps

### Step 1: Create Item Class (2 hours)

1. Create header file with class definition
2. Implement basic constructors and methods
3. Add position and property management

### Step 2: Create ItemFactory (3 hours)

1. Implement singleton pattern
2. Add JSON loading with nlohmann/json
3. Create template system
4. Implement create() method

### Step 3: Create JSON Data File (1 hour)

1. Design item data structure
2. Create initial set of 10-15 items
3. Add depth ranges for spawning

### Step 4: Create ItemManager (2 hours)

1. Implement item storage and retrieval
2. Add spawn methods
3. Implement position-based queries

### Step 5: Integrate with GameScreen (2 hours)

1. Add ItemManager to GameScreen
2. Implement initial item spawning
3. Add rendering integration

### Step 6: Add Rendering (1 hour)

1. Implement item rendering in correct layer
2. Add color mapping
3. Integrate with FOV system

### Step 7: Write Tests (2 hours)

1. Create unit tests for Item class
2. Create unit tests for ItemFactory
3. Create integration tests
4. Ensure all tests pass

### Step 8: Documentation (1 hour)

1. Update code comments
2. Create item system documentation
3. Update CHANGELOG

## Success Criteria

1. ✅ Items load successfully from JSON
2. ✅ Items appear on the map with correct symbols and colors
3. ✅ Items only render when visible
4. ✅ Multiple items can exist at the same location
5. ✅ Item factory creates items with correct properties
6. ✅ All unit tests pass
7. ✅ No memory leaks (valgrind clean)
8. ✅ Code follows project style guidelines

## Dependencies

- Existing Entity system (for position management patterns)
- Map system (for valid placement)
- FOV system (for visibility)
- Rendering system (for display)
- JSON library (nlohmann/json)

## Future Considerations (Phase 10.2 and 10.3)

- Inventory system will need item references
- Pickup/drop mechanics
- Item usage and effects
- Equipment slots for weapons/armor
- Item identification system
- Cursed/blessed status
- Item enchantments
- Unique/artifact items

## Configuration

Add to `config.yml`:

```yaml
items:
  spawn_count_min: 5
  spawn_count_max: 10
  spawn_in_corridors: false
  gold_drop_chance: 0.3
  item_drop_chance: 0.2
```

## Log Categories

Add to logging system:

- `LOG_ITEM()` - Item creation, spawning, removal
- `LOG_LOOT()` - Loot generation and drops

## Potential Issues

1. **Performance**: Many items on screen could impact rendering
   - Solution: Only render visible items
   - Consider item culling for large numbers

2. **Save/Load**: Items need serialization
   - Solution: Add to save system in parallel
   - Use JSON for item state

3. **Stacking Logic**: Complex for different item types
   - Solution: Start simple, enhance later
   - Focus on potions/scrolls first

4. **Color System**: Terminal colors are limited
   - Solution: Create color palette mapping
   - Reuse colors with different symbols

## Git Tag

Upon successful completion: `git tag v0.10.1-item-entity`
