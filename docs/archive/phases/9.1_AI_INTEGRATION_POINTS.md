# Phase 9.1: Combat System - AI Integration Points

**Integration Focus:** Connecting CombatSystem with Phase 8.3 Basic AI
**Critical Requirement:** Maintain existing AI behavior while enhancing combat

## Current AI-Combat Integration Analysis

### âœ… Existing AI Combat Behavior (Phase 8.3)

#### Monster AI Combat Actions

```cpp
// From src/game_manager.cpp:280-290
if (next_pos == player->getPosition()) {
    // Attack player
    int damage = monster->calculateDamage();
    player->takeDamage(damage);

    if (message_log) {
        message_log->addCombatMessage(
            monster->name + " attacks for " + std::to_string(damage) + " damage!"
        );
    }
    continue;
}
```

#### AI State Transitions Based on Health

```cpp
// From src/monster_ai.cpp:69-75
float health_percent = (float)monster.hp / (float)monster.max_hp;
bool should_flee = health_percent < 0.25f && monster.species != "orc";

if (can_see) {
    if (should_flee) {
        data->current_state = AIState::FLEEING;
    } else if (distance <= HOSTILE_RANGE) {
        data->current_state = AIState::HOSTILE;
    }
}
```

### ðŸ”„ Required Integration Changes

## 1. GameManager Combat Integration

### Current Implementation

```cpp
// src/game_manager.cpp - updateMonsters()
if (next_pos == player->getPosition()) {
    int damage = monster->calculateDamage();
    player->takeDamage(damage);
    // Basic message logging
}
```

### Updated Implementation

```cpp
// Enhanced integration with CombatSystem
if (next_pos == player->getPosition()) {
    // Use CombatSystem for attack resolution
    auto result = combat_system->processAttack(*monster, *player);

    // AI can react to combat results
    if (result.fatal) {
        // Player death handling
        setState(GameState::GAME_OVER);
    }

    // Update AI state based on combat outcome
    if (result.hit && result.damage > 0) {
        // Monster successfully attacked - may become more aggressive
        monster_ai->onSuccessfulAttack(*monster, *player, result);
    } else {
        // Attack missed - AI may change tactics
        monster_ai->onMissedAttack(*monster, *player);
    }

    continue;
}
```

## 2. MonsterAI Combat Decision Making

### Enhanced AI Combat Intelligence

```cpp
// New methods for MonsterAI class
class MonsterAI {
public:
    // Combat evaluation methods
    bool shouldAttack(const Monster& monster, const Player& player, const CombatSystem& combat);
    bool shouldFlee(const Monster& monster, const Player& player, const CombatSystem& combat);
    float evaluateCombatEffectiveness(const Monster& monster, const Player& player, const CombatSystem& combat);

    // Combat event callbacks
    void onSuccessfulAttack(Monster& monster, const Player& player, const CombatSystem::CombatResult& result);
    void onMissedAttack(Monster& monster, const Player& player);
    void onTakeDamage(Monster& monster, const Entity& attacker, int damage);

private:
    // Combat analysis
    float calculateExpectedDamage(const Monster& monster, const Player& player, const CombatSystem& combat);
    float calculateSurvivalChance(const Monster& monster, const Player& player, const CombatSystem& combat);
};
```

### Enhanced State Transitions

```cpp
// Updated state evaluation with combat system
void MonsterAI::updateState(Monster& monster, const Player& player, const Map& map) {
    AIData* data = getAIData(monster);

    // Get combat system for evaluation
    CombatSystem* combat = // ... get from game manager

    bool can_see = canSeePlayer(monster, player, map);
    float distance = Pathfinding::getDistance(monster.getPosition(), player.getPosition());

    // Enhanced flee decision with combat analysis
    float health_percent = (float)monster.hp / (float)monster.max_hp;
    float combat_effectiveness = evaluateCombatEffectiveness(monster, player, *combat);
    bool should_flee = (health_percent < 0.25f || combat_effectiveness < 0.3f) &&
                       monster.species != "orc";

    if (can_see) {
        if (should_flee) {
            data->current_state = AIState::FLEEING;
        } else if (shouldAttack(monster, player, *combat) && distance <= HOSTILE_RANGE) {
            data->current_state = AIState::HOSTILE;
        } else if (distance <= ALERT_RANGE) {
            data->current_state = AIState::ALERT;
        }
    }

    // ... rest of state logic
}
```

## 3. Combat Effectiveness Evaluation

### AI Combat Metrics

```cpp
float MonsterAI::evaluateCombatEffectiveness(const Monster& monster, const Player& player, const CombatSystem& combat) {
    // Calculate expected damage output
    float expected_damage = calculateExpectedDamage(monster, player, combat);

    // Calculate survival probability
    float survival_chance = calculateSurvivalChance(monster, player, combat);

    // Factor in health percentage
    float health_factor = (float)monster.hp / (float)monster.max_hp;

    // Combined effectiveness score (0.0 to 1.0)
    return (expected_damage * 0.4f + survival_chance * 0.4f + health_factor * 0.2f);
}

float MonsterAI::calculateExpectedDamage(const Monster& monster, const Player& player, const CombatSystem& combat) {
    // Simulate hit probability
    int attack_bonus = monster.getAttackBonus();
    int player_defense = combat.getDefenseValue(player);

    // Estimate hit chance based on stats
    float hit_chance = std::max(0.05f, std::min(0.95f,
        (21.0f + attack_bonus - player_defense) / 20.0f));

    // Average damage on hit
    float avg_damage = monster.getBaseDamage() / 2.0f;

    return hit_chance * avg_damage;
}
```

## 4. Monster Behavior Adaptations

### Tactical AI Improvements

```cpp
// Enhanced monster decision making based on combat stats
Point MonsterAI::chooseHostileMove(Monster& monster, const Player& player, const Map& map) {
    AIData* data = getAIData(monster);
    Point current = monster.getPosition();
    Point target = player.getPosition();

    // Get combat system for tactical evaluation
    CombatSystem* combat = // ... get from game manager

    // Evaluate if we should attack or reposition
    if (Pathfinding::getDistance(current, target) == 1) {
        // Adjacent to player - evaluate attack vs retreat
        float combat_effectiveness = evaluateCombatEffectiveness(monster, player, *combat);

        if (combat_effectiveness < 0.4f && monster.hp < monster.max_hp * 0.5f) {
            // Low effectiveness and health - consider tactical retreat
            return chooseFleeingMove(monster, player, map);
        }

        // Stay and fight - return current position to attack
        return current;
    }

    // Not adjacent - use existing pathfinding logic
    // ... existing movement code
}
```

### Combat Event Response

```cpp
void MonsterAI::onSuccessfulAttack(Monster& monster, const Player& player, const CombatSystem::CombatResult& result) {
    AIData* data = getAIData(monster);

    // Successful attack reinforces aggressive behavior
    if (result.critical) {
        // Critical hit - monster becomes more confident
        data->aggression_modifier += 0.2f;
    }

    if (result.fatal) {
        // Player defeated - victory state
        data->current_state = AIState::IDLE;
        data->victory_counter = 10; // Celebration behavior
    }
}

void MonsterAI::onMissedAttack(Monster& monster, const Player& player) {
    AIData* data = getAIData(monster);

    // Missed attack may cause doubt
    data->miss_counter++;
    if (data->miss_counter >= 3) {
        // Multiple misses - consider different tactics
        data->aggression_modifier -= 0.1f;
        data->miss_counter = 0;
    }
}

void MonsterAI::onTakeDamage(Monster& monster, const Entity& attacker, int damage) {
    AIData* data = getAIData(monster);

    // Taking damage triggers threat assessment
    float health_percent = (float)monster.hp / (float)monster.max_hp;

    if (health_percent < 0.25f) {
        // Critical health - force flee evaluation
        data->current_state = AIState::FLEEING;
        data->panic_mode = true;
    } else if (damage > monster.max_hp * 0.3f) {
        // High damage - become more cautious
        data->aggression_modifier -= 0.3f;
    }

    // Remember the attacker
    data->last_attacker = &attacker;
    data->last_damage_taken = damage;
}
```

## 5. Integration Implementation Steps

### Step 1: Extend AIData Structure

```cpp
// Add to MonsterAI::AIData
struct AIData {
    // ... existing fields ...

    // Combat-related AI data
    float aggression_modifier = 0.0f;  // -1.0 to 1.0
    int miss_counter = 0;
    int victory_counter = 0;
    bool panic_mode = false;
    const Entity* last_attacker = nullptr;
    int last_damage_taken = 0;
    float last_combat_effectiveness = 0.5f;
};
```

### Step 2: Update GameManager Integration

```cpp
// Modify src/game_manager.cpp
void GameManager::updateMonsters() {
    // ... existing code ...

    // Enhanced combat integration
    if (next_pos == player->getPosition()) {
        auto result = combat_system->processAttack(*monster, *player);

        // Notify AI of combat result
        monster_ai->onSuccessfulAttack(*monster, *player, result);

        // Handle player death
        if (result.fatal) {
            setState(GameState::GAME_OVER);
        }
        continue;
    }

    // ... rest of movement logic
}
```

### Step 3: Add Combat Callbacks to Monster Class

```cpp
// Enhance Monster class
class Monster : public Entity {
public:
    // ... existing methods ...

    // Combat event overrides
    void onAttack(Entity& target) override;
    void onHit(Entity& attacker, int damage) override;
    void onMiss(Entity& attacker) override;

    // AI integration
    void setAI(MonsterAI* ai) { monster_ai = ai; }
    MonsterAI* getAI() const { return monster_ai; }

private:
    MonsterAI* monster_ai = nullptr;
};
```

## 6. Testing Integration Points

### Unit Tests for AI-Combat Integration

```cpp
TEST_CASE("AI Combat Integration", "[ai][combat]") {
    MonsterAI ai;
    CombatSystem combat;

    SECTION("Combat effectiveness evaluation") {
        Monster strong_monster(5, 5, "orc");
        strong_monster.setStats(20, 20, 8, 3, 100, 15);

        Player weak_player(6, 5);
        weak_player.hp = 5;
        weak_player.attack = 3;
        weak_player.defense = 1;

        float effectiveness = ai.evaluateCombatEffectiveness(strong_monster, weak_player, combat);
        REQUIRE(effectiveness > 0.7f); // Should be highly effective
    }

    SECTION("Flee decision making") {
        Monster weak_monster(5, 5, "rat");
        weak_monster.setStats(3, 10, 2, 0, 100, 2); // Low health

        Player strong_player(6, 5);
        strong_player.attack = 8;

        bool should_flee = ai.shouldFlee(weak_monster, strong_player, combat);
        REQUIRE(should_flee == true);
    }
}
```

## 7. Backward Compatibility

### Maintaining Existing Behavior

- All existing AI behaviors continue to work
- Combat damage calculations remain consistent
- Monster spawning and room assignment unaffected
- Player experience unchanged during transition

### Gradual Enhancement

- Phase 9.1: Enhanced combat calculations with AI awareness
- Phase 9.2: Full bump-to-attack integration
- Phase 9.3: Death handling with AI state cleanup
- Future: Advanced tactical AI with equipment consideration

## Integration Success Criteria

### Functional Requirements âœ…

- [ ] AI continues to make combat decisions
- [ ] Monster fleeing behavior works with new combat system
- [ ] Combat effectiveness influences AI state transitions
- [ ] All existing AI test cases continue to pass

### Performance Requirements âœ…

- [ ] No performance regression in AI processing
- [ ] Combat evaluation adds < 0.1ms per monster per turn
- [ ] Memory usage increase < 5% for AI data

### Quality Requirements âœ…

- [ ] Clean separation between AI and combat systems
- [ ] Combat system remains unit-testable independently
- [ ] AI system remains testable with mock combat
- [ ] Integration points are well-documented

The integration maintains the intelligent behavior established in Phase 8.3 while adding sophisticated combat awareness that will enhance tactical gameplay depth.
