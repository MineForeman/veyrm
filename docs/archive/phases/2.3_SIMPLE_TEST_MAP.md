# Phase 2.3: Simple Test Map

## Overview

Create a reliable, hardcoded test map for development and debugging. This phase consolidates the existing map generation code into a proper system and establishes patterns for future procedural generation.

## Current State Analysis

### What We Have

From the GameManager constructor, we already have:
- ✅ Multiple room creation (5 connected rooms)
- ✅ Corridor connections between rooms
- ✅ Stairs placement
- ✅ Player spawn point
- ✅ Working map dimensions (80x24 default)

### What Needs Improvement

- ❌ Map generation is hardcoded in GameManager constructor
- ❌ No separation between test maps and production maps
- ❌ No validation of room placement
- ❌ No standardized test scenarios
- ❌ No map templates or presets

## Technical Requirements

### 1. MapGenerator Class

Create a dedicated class for map generation:

```cpp
class MapGenerator {
public:
    // Test map generators
    static void generateTestRoom(Map& map, int width = 20, int height = 20);
    static void generateTestDungeon(Map& map);
    static void generateDebugMap(Map& map);
    
    // Validation
    static bool validateMap(const Map& map);
    static bool isFullyConnected(const Map& map);
    
    // Utilities
    static Point findSafeSpawnPoint(const Map& map);
    static void placeStairs(Map& map, const Point& position);
    
private:
    // Room generation helpers
    static bool canPlaceRoom(const Map& map, int x, int y, int w, int h);
    static void carveRoom(Map& map, int x, int y, int w, int h);
    static void carveCorridor(Map& map, const Point& start, const Point& end);
};
```

### 2. Test Map Templates

Define standard test scenarios:

```cpp
enum class TestMapType {
    SINGLE_ROOM,      // 20x20 room with walls
    CONNECTED_ROOMS,  // Current 5-room layout
    CORRIDOR_TEST,    // Long corridors for pathfinding
    COMBAT_ARENA,    // Open space for combat testing
    MAZE,            // Complex layout for FOV testing
    STRESS_TEST      // Maximum size map (200x200)
};

struct MapTemplate {
    std::string name;
    int width, height;
    std::vector<RoomDef> rooms;
    std::vector<CorridorDef> corridors;
    Point player_start;
    Point stairs_down;
};
```

### 3. Room Definition Structure

```cpp
struct RoomDef {
    int x, y;        // Top-left corner
    int width, height;
    std::string type; // "normal", "treasure", "boss"
    
    // Validation
    bool isValid() const {
        return width >= 3 && height >= 3;
    }
    
    // Utility
    Point center() const {
        return Point(x + width/2, y + height/2);
    }
    
    bool overlaps(const RoomDef& other) const {
        return !(x + width <= other.x || 
                other.x + other.width <= x ||
                y + height <= other.y ||
                other.y + other.height <= y);
    }
};
```

### 4. Map Validation System

```cpp
class MapValidator {
public:
    struct ValidationResult {
        bool valid;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
        
        // Statistics
        int room_count;
        int walkable_tiles;
        int wall_tiles;
        bool has_stairs_down;
        bool has_spawn_point;
    };
    
    static ValidationResult validate(const Map& map) {
        ValidationResult result;
        
        // Check for isolated areas
        if (!checkConnectivity(map)) {
            result.errors.push_back("Map has disconnected areas");
        }
        
        // Check for spawn point
        if (!findWalkableTile(map)) {
            result.errors.push_back("No walkable tiles for spawn");
        }
        
        // Check for minimum size
        if (countWalkableTiles(map) < 20) {
            result.warnings.push_back("Map has very few walkable tiles");
        }
        
        return result;
    }
};
```

## Implementation Plan

### Step 1: Extract Current Map Generation

Move the existing map generation from GameManager to MapGenerator:

```cpp
// In MapGenerator::generateTestDungeon()
void MapGenerator::generateTestDungeon(Map& map) {
    // Clear map
    map.fill(TileType::VOID);
    
    // Create rooms (existing code from GameManager)
    map.createRoom(10, 5, 20, 10);   // Top-left
    map.createRoom(35, 5, 20, 10);   // Top-right
    map.createRoom(10, 18, 20, 10);  // Bottom-left
    map.createRoom(35, 18, 25, 10);  // Bottom-right
    map.createRoom(22, 10, 16, 12);  // Central
    
    // Connect with corridors
    map.createCorridor(Point(20, 10), Point(30, 10));
    map.createCorridor(Point(37, 10), Point(45, 10));
    // ... etc
    
    // Place stairs
    map.setTile(55, 25, TileType::STAIRS_DOWN);
}
```

### Step 2: Create Simple Test Room

Implement the basic 20x20 test room:

```cpp
void MapGenerator::generateTestRoom(Map& map, int width, int height) {
    // Fill with void
    map.fill(TileType::VOID);
    
    // Calculate room position (centered)
    int room_x = (map.getWidth() - width) / 2;
    int room_y = (map.getHeight() - height) / 2;
    
    // Create room
    for (int y = room_y; y < room_y + height; y++) {
        for (int x = room_x; x < room_x + width; x++) {
            if (x == room_x || x == room_x + width - 1 ||
                y == room_y || y == room_y + height - 1) {
                map.setTile(x, y, TileType::WALL);
            } else {
                map.setTile(x, y, TileType::FLOOR);
            }
        }
    }
    
    // Place stairs in corner
    map.setTile(room_x + width - 2, room_y + height - 2, 
                TileType::STAIRS_DOWN);
}
```

### Step 3: Add Map Selection

Update GameManager to support map selection:

```cpp
enum class MapMode {
    TEST_ROOM,
    TEST_DUNGEON,
    RANDOM,
    FROM_FILE
};

class GameManager {
    void initializeMap(MapMode mode = MapMode::TEST_DUNGEON) {
        switch (mode) {
            case MapMode::TEST_ROOM:
                MapGenerator::generateTestRoom(*map);
                player_x = map->getWidth() / 2;
                player_y = map->getHeight() / 2;
                break;
                
            case MapMode::TEST_DUNGEON:
                MapGenerator::generateTestDungeon(*map);
                player_x = 30;
                player_y = 15;
                break;
                
            // Future: Random generation, file loading
        }
        
        // Validate map
        auto validation = MapValidator::validate(*map);
        if (!validation.valid) {
            // Log errors
            for (const auto& error : validation.errors) {
                message_log->addSystemMessage("Map Error: " + error);
            }
        }
    }
};
```

## Test Scenarios

### 1. Basic Room Test
- Single 20x20 room
- Player spawns in center
- Stairs in corner
- All tiles visible

### 2. Movement Test
- Long corridors
- Tight passages (1-tile wide)
- Open areas
- Tests collision detection

### 3. Rendering Test
- Multiple room types
- Different tile types
- Tests viewport scrolling
- Tests color schemes

### 4. Performance Test
- Large map (200x200)
- Many rooms and corridors
- Tests rendering performance
- Tests memory usage

## File Structure

```
include/
  map_generator.h    # Map generation functions
  map_validator.h    # Map validation system
  map_templates.h    # Predefined map layouts

src/
  map_generator.cpp  # Generation implementation
  map_validator.cpp  # Validation implementation
  
data/
  maps/
    test_room.json   # Serialized test maps
    test_dungeon.json
```

## Success Criteria

1. ✅ Clean separation of map generation from game logic
2. ✅ At least 3 different test map types
3. ✅ Map validation ensures playability
4. ✅ Player can spawn and move in all test maps
5. ✅ Stairs are accessible in all maps
6. ✅ Performance acceptable on largest test map

## Testing Strategy

### Unit Tests
```cpp
TEST_CASE("Test room generation") {
    Map map(80, 24);
    MapGenerator::generateTestRoom(map, 20, 20);
    
    // Check room exists
    REQUIRE(map.getTile(40, 12) == TileType::FLOOR);
    
    // Check walls exist
    REQUIRE(map.getTile(30, 2) == TileType::WALL);
    
    // Check stairs placed
    bool has_stairs = false;
    for (int y = 0; y < map.getHeight(); y++) {
        for (int x = 0; x < map.getWidth(); x++) {
            if (map.getTile(x, y) == TileType::STAIRS_DOWN) {
                has_stairs = true;
                break;
            }
        }
    }
    REQUIRE(has_stairs);
}

TEST_CASE("Map validation") {
    Map map(80, 24);
    MapGenerator::generateTestRoom(map);
    
    auto result = MapValidator::validate(map);
    REQUIRE(result.valid);
    REQUIRE(result.has_spawn_point);
    REQUIRE(result.has_stairs_down);
}
```

### Integration Tests
1. Generate each map type
2. Spawn player
3. Verify movement works
4. Verify rendering works
5. Check memory usage

## Future Enhancements

1. **Procedural Generation** - Random room placement
2. **Map Serialization** - Save/load maps from JSON
3. **Map Editor** - Interactive map creation tool
4. **Themed Maps** - Different tilesets and layouts
5. **Multi-level** - Stairs connect between maps
6. **Special Rooms** - Treasure rooms, boss arenas

## Dependencies

- Phase 2.1: Tile System ✅
- Phase 2.2: Map Rendering ✅
- No external dependencies

## Next Steps

After Phase 2.3:
- Phase 3.1: Basic Monsters (entities in the map)
- Phase 3.2: Turn Manager (creature actions)
- Phase 6.1: Field of View (limit visibility)

## Implementation Checklist

- [x] Create MapGenerator class
- [x] Extract existing generation code
- [x] Implement generateTestRoom()
- [x] Implement generateTestDungeon()
- [x] Create MapValidator class
- [x] Add validation checks
- [x] Update GameManager to use MapGenerator
- [x] Add command-line map selection option
- [x] Fix corridor wall generation
- [x] Ensure corridors connect properly to rooms
- [ ] Write unit tests
- [x] Test all map types
- [x] Document API
- [ ] Update IMPLEMENTATION_PLAN.md

## Notes

- Keep it simple - this is for testing, not final generation
- Ensure all maps are playable (connected, has spawn)
- Make it easy to switch between map types for debugging
- Consider adding a "map" command to switch maps at runtime
- Performance is not critical for test maps

## Implementation Summary (Completed)

### What Was Built

1. **MapGenerator Class** - Fully implemented with multiple map types:
   - `TEST_ROOM` - Single 20x20 centered room
   - `TEST_DUNGEON` - 5-room connected layout (default)
   - `CORRIDOR_TEST` - Long corridors for movement testing
   - `COMBAT_ARENA` - Large open space with pillars
   - `STRESS_TEST` - Procedurally generated multi-room map

2. **MapValidator Class** - Complete validation system:
   - Connectivity checking via flood fill
   - Walkable tile counting
   - Room identification
   - Spawn point validation
   - Stairs validation
   - Warning/error reporting

3. **Command-Line Map Selection**:

   ```bash
   ./build/bin/veyrm --map <type>
   # Types: room, dungeon, corridor, arena, stress
   ```

4. **Build Script Integration**:
   - Interactive map selection menu
   - Direct map type specification: `./build.sh run arena`

5. **Corridor Improvements**:
   - Corridors now have proper walls on both sides
   - Corridors create doorways when connecting to rooms
   - L-shaped corridor generation with corner wall handling

### Key Features

- **Separation of Concerns**: Map generation completely separated from GameManager
- **Extensible Design**: Easy to add new map types via MapType enum
- **Robust Validation**: Maps are validated for playability before use
- **Proper Wall Generation**: Corridors have walls, corners are handled correctly
- **Room Connectivity**: All rooms are properly connected via corridors

### Usage Examples

```cpp
// In code
MapGenerator::generate(map, MapType::TEST_DUNGEON);

// Command line
./build/bin/veyrm --map room      # Single room
./build/bin/veyrm --map corridor  # Corridor test
./build.sh run                    # Interactive selection
./build.sh run stress             # Direct selection
```

### Map Statistics (from validation)

- Test Room: ~324 walkable tiles, 1 room
- Test Dungeon: ~604 walkable tiles, 1 connected area
- Corridor Test: ~178 walkable tiles, 2 rooms + corridors
- Combat Arena: ~678 walkable tiles, 1 large room
- Stress Test: Variable, typically 20-40 rooms

This phase is now complete and ready for use in subsequent development phases.
